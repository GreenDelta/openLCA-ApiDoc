<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Inter-process communication with openLCA</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="servers.html"><strong aria-hidden="true">2.</strong> Stand-alone servers</a></li><li class="chapter-item expanded "><a href="examples/examples.html"><strong aria-hidden="true">3.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="examples/pyipc_from_scratch.html"><strong aria-hidden="true">3.1.</strong> Python IPC: From scratch</a></li><li class="chapter-item expanded "><a href="examples/parameters.html"><strong aria-hidden="true">3.2.</strong> Calculation parameters</a></li></ol></li><li class="chapter-item expanded "><a href="data/data.html"><strong aria-hidden="true">4.</strong> Data management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="data/get_descriptors.html"><strong aria-hidden="true">4.1.</strong> Get descriptors</a></li><li class="chapter-item expanded "><a href="data/get_by_id.html"><strong aria-hidden="true">4.2.</strong> Get by ID</a></li><li class="chapter-item expanded "><a href="data/get_by_name.html"><strong aria-hidden="true">4.3.</strong> Get by name</a></li><li class="chapter-item expanded "><a href="data/get_descriptor.html"><strong aria-hidden="true">4.4.</strong> Get descriptor</a></li><li class="chapter-item expanded "><a href="data/get_all.html"><strong aria-hidden="true">4.5.</strong> Get all</a></li><li class="chapter-item expanded "><a href="data/get_parameters.html"><strong aria-hidden="true">4.6.</strong> Get parameters</a></li><li class="chapter-item expanded "><a href="data/get_providers.html"><strong aria-hidden="true">4.7.</strong> Get providers</a></li><li class="chapter-item expanded "><a href="data/get_providers_for_flow.html"><strong aria-hidden="true">4.8.</strong> Get providers for flow</a></li><li class="chapter-item expanded "><a href="data/put.html"><strong aria-hidden="true">4.9.</strong> Insert or update a data set</a></li><li class="chapter-item expanded "><a href="data/create-system.html"><strong aria-hidden="true">4.10.</strong> Create a product system</a></li><li class="chapter-item expanded "><a href="data/delete.html"><strong aria-hidden="true">4.11.</strong> Delete a data set</a></li></ol></li><li class="chapter-item expanded "><a href="results/results.html"><strong aria-hidden="true">5.</strong> Calculation and results</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="results/calculate.html"><strong aria-hidden="true">5.1.</strong> Calculate</a></li><li class="chapter-item expanded "><a href="results/get_state.html"><strong aria-hidden="true">5.2.</strong> Get state</a></li><li class="chapter-item expanded "><a href="results/dispose.html"><strong aria-hidden="true">5.3.</strong> Dispose result</a></li><li class="chapter-item expanded "><a href="results/simulate.html"><strong aria-hidden="true">5.4.</strong> Monte Carlo Simulations</a></li><li class="chapter-item expanded "><a href="results/elements/tech-flows.html"><strong aria-hidden="true">5.5.</strong> Technosphere flows</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="results/tech-flows/demand.html"><strong aria-hidden="true">5.5.1.</strong> The final demand</a></li><li class="chapter-item expanded "><a href="results/tech-flows/total-requirements.html"><strong aria-hidden="true">5.5.2.</strong> Total requirements</a></li><li class="chapter-item expanded "><a href="results/tech-flows/direct-requirements.html"><strong aria-hidden="true">5.5.3.</strong> Direct requirements</a></li><li class="chapter-item expanded "><a href="results/tech-flows/scaling-vector.html"><strong aria-hidden="true">5.5.4.</strong> Scaling factors</a></li><li class="chapter-item expanded "><a href="results/tech-flows/totality-factors.html"><strong aria-hidden="true">5.5.5.</strong> Totality factors</a></li><li class="chapter-item expanded "><a href="results/tech-flows/unscaled-requirements.html"><strong aria-hidden="true">5.5.6.</strong> Unscaled requirements</a></li></ol></li><li class="chapter-item expanded "><a href="results/elements/envi-flows.html"><strong aria-hidden="true">5.6.</strong> Intervention flows</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="results/envi-flows/inventory-result.html"><strong aria-hidden="true">5.6.1.</strong> Inventory result</a></li><li class="chapter-item expanded "><a href="results/envi-flows/direct-contributions.html"><strong aria-hidden="true">5.6.2.</strong> Direct contributions</a></li><li class="chapter-item expanded "><a href="results/envi-flows/total-values.html"><strong aria-hidden="true">5.6.3.</strong> Total values</a></li><li class="chapter-item expanded "><a href="results/envi-flows/direct-results.html"><strong aria-hidden="true">5.6.4.</strong> Direct process result</a></li><li class="chapter-item expanded "><a href="results/envi-flows/total-results.html"><strong aria-hidden="true">5.6.5.</strong> Total process result</a></li><li class="chapter-item expanded "><a href="results/envi-flows/intensities.html"><strong aria-hidden="true">5.6.6.</strong> Intensities</a></li><li class="chapter-item expanded "><a href="results/envi-flows/unscaled.html"><strong aria-hidden="true">5.6.7.</strong> Unscaled flows</a></li><li class="chapter-item expanded "><a href="results/envi-flows/upstream.html"><strong aria-hidden="true">5.6.8.</strong> Upstream results</a></li><li class="chapter-item expanded "><a href="results/envi-flows/upstream_trees.html"><strong aria-hidden="true">5.6.9.</strong> Upstream trees</a></li></ol></li><li class="chapter-item expanded "><a href="results/elements/impact-categories.html"><strong aria-hidden="true">5.7.</strong> Impact categories</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="results/impacts/impact-result.html"><strong aria-hidden="true">5.7.1.</strong> Impact assessment result</a></li><li class="chapter-item expanded "><a href="results/impacts/normalized.html"><strong aria-hidden="true">5.7.2.</strong> Normalized results</a></li><li class="chapter-item expanded "><a href="results/impacts/weighted.html"><strong aria-hidden="true">5.7.3.</strong> Weighted results</a></li><li class="chapter-item expanded "><a href="results/impacts/direct-contributions.html"><strong aria-hidden="true">5.7.4.</strong> Direct contributions</a></li><li class="chapter-item expanded "><a href="results/impacts/direct-results.html"><strong aria-hidden="true">5.7.5.</strong> Direct process result</a></li><li class="chapter-item expanded "><a href="results/impacts/total-results.html"><strong aria-hidden="true">5.7.6.</strong> Total process result</a></li><li class="chapter-item expanded "><a href="results/impacts/intensities.html"><strong aria-hidden="true">5.7.7.</strong> Intensities</a></li><li class="chapter-item expanded "><a href="results/impacts/upstream.html"><strong aria-hidden="true">5.7.8.</strong> Upstream results</a></li><li class="chapter-item expanded "><a href="results/impacts/upstream_trees.html"><strong aria-hidden="true">5.7.9.</strong> Upstream trees</a></li></ol></li><li class="chapter-item expanded "><a href="results/elements/costs.html"><strong aria-hidden="true">5.8.</strong> Costs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="results/costs/cost-result.html"><strong aria-hidden="true">5.8.1.</strong> Life cycle costing result</a></li><li class="chapter-item expanded "><a href="results/costs/direct-contributions.html"><strong aria-hidden="true">5.8.2.</strong> Direct contributions</a></li><li class="chapter-item expanded "><a href="results/costs/total-values.html"><strong aria-hidden="true">5.8.3.</strong> Total values</a></li><li class="chapter-item expanded "><a href="results/costs/intensities.html"><strong aria-hidden="true">5.8.4.</strong> Intensities</a></li><li class="chapter-item expanded "><a href="results/costs/unscaled.html"><strong aria-hidden="true">5.8.5.</strong> Unscaled costs</a></li><li class="chapter-item expanded "><a href="results/costs/upstream.html"><strong aria-hidden="true">5.8.6.</strong> Upstream results</a></li><li class="chapter-item expanded "><a href="results/costs/upstream_trees.html"><strong aria-hidden="true">5.8.7.</strong> Upstream trees</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Inter-process communication with openLCA</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>openLCA provides an API for inter-process communication (IPC) that can be used
by any application written in any programming language (e.g. Python,
JavaScript/TypeScript, .Net, Go, etc.)<sup class="footnote-reference"><a href="#java_note">1</a></sup>. This IPC protocol is
provided by an openLCA server which can be a running instance of the openLCA
desktop application or a web-server with an openLCA back-end that exposes this
protocol. An application can connect to such an IPC server to call functions in
openLCA:</p>
<pre><code>
        +--------+                  +--------------------+
        | Client | &lt;--------------&gt; | openLCA IPC Server |
        +--------+                  +--------------------+
                    IPC - Protocol
                    * data management
                    * calculations
                    * result details
                    * ...
</code></pre>
<h2 id="starting-an-ipc-server"><a class="header" href="#starting-an-ipc-server">Starting an IPC server</a></h2>
<p>In the openLCA desktop application, you can start an IPC server for the
currently active database from the tools menu: <code>Tools &gt; Developer tools &gt; IPC Server</code>. This brings up the following dialog where you can start and stop the
server:</p>
<p><img src="./images/start-ipc-server.png" alt="Starting an IPC server in openLCA" /></p>
<p>For headless stand-alone servers, please see the next chapter.</p>
<h2 id="available-protocols"><a class="header" href="#available-protocols">Available protocols</a></h2>
<p>In the dialog, you can select to start a standard IPC server or a
<a href="https://grpc.io/">gRPC</a> server. The standard IPC server is based on the
<a href="https://www.jsonrpc.org/">JSON-RPC</a> protocol provided over HTTP. This protocol
is easy to implement as it is just based on JSON and HTTP. For example, it can
be directly used from a web-browser using the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch
API</a>.</p>
<p>The <a href="https://grpc.io/">gRPC</a> protocol is another option, especially when you are
already familiar with it or when your platform has good support for this option.
In this case, you can just generate the client side interface from the <a href="https://github.com/GreenDelta/olca-proto">openLCA
service declaration</a>.</p>
<p>A third option is the
<a href="https://en.wikipedia.org/wiki/Representational_state_transfer">REST</a> API
provided by openLCA web-services. This protocol is also just based on JSON and
HTTP and especially useful when integrating the openLCA back-end into
web-applications.</p>
<p>In this documentation we try to cover all these protocols as they just provide
an interface to the same service back-end of the openLCA kernel. Also, all of
these protocols are based on the <a href="http://greendelta.github.io/olca-schema/">openLCA
Schema</a> as the data exchange format.
Thus, parameter and return types of the this documentations often link to their
respective description in the openLCA schema documentation.</p>
<h2 id="client-libraries-and-example-applications"><a class="header" href="#client-libraries-and-example-applications">Client libraries and example applications</a></h2>
<p>The table below lists some client libraries and demo applications based on the
openLCA IPC protocol:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>Language</th><th>Type</th><th>Protocol</th></tr></thead><tbody>
<tr><td><a href="https://github.com/GreenDelta/olca-ipc.py">olca-opc.py</a></td><td>Python</td><td>Client library</td><td>JSON-RPC, REST</td></tr>
<tr><td><a href="https://github.com/GreenDelta/olca-ipc.ts">olca-ipc.ts</a></td><td>JavaScript/TypeScript</td><td>Client library</td><td>JSON-RPC, REST</td></tr>
<tr><td><a href="https://github.com/msrocka/ProtoLCA-Demo">ProtoLCA-Demo</a></td><td>C#</td><td>Demo</td><td>gRPC</td></tr>
<tr><td><a href="https://github.com/msrocka/protolca-js-example">protolca-js-example</a></td><td>JavaScript/Node</td><td>Client library</td><td>gRPC</td></tr>
<tr><td><a href="https://github.com/GreenDelta/olcarpc.py">olcarpc.py</a></td><td>Python</td><td>Client library</td><td>gRPC</td></tr>
</tbody></table>
</div>
<hr />
<p><sup class="footnote-reference"><a href="#java_note">1</a></sup> openLCA is a Java application and if your application is written in
a language that also runs on the Java virtual machine (like Java, Kotlin, Scala,
Clojure etc.) it is recommended to directly use the <a href="https://github.com/GreenDelta/olca-modules">openLCA Java
API</a> instead of an IPC server. The
kernel of openLCA can be used independently from the user interface and can be
integrated as a set of standard Java libraries in JVM based applications. For
example, the integrated Python editor in openLCA is in fact a Python
implementation for the JVM (<a href="https://www.jython.org/">Jython</a>), with which you
can call the Java API of openLCA.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stand-alone-servers"><a class="header" href="#stand-alone-servers">Stand-alone servers</a></h1>
<p>As shown in the section before, it is easy to start an IPC server in openLCA
from the user interface but it is of course also possible to run these servers
as stand-alone servers. The JSON-RPC and gRPC servers are part of the <a href="https://github.com/GreenDelta/olca-modules">openLCA
modules</a>, the
<a href="https://github.com/GreenDelta/gdt-server">gdt-server</a> provides an
implementation of the Rest API of the openLCA IPC protocol. All these servers
provide a common command line interface with which a server can be configured
and started. The parameters of the configuration are listed below. All
parameters are optional. By default a server uses the default openLCA workspace
folder as used by the desktop application (<code>~/openLCA-data-1.4</code>) and connects to
the database with the name <code>database</code> in that folder:</p>
<pre><code>
-data &lt;path to data folder&gt;

  The path to the data folder that contains the database and possible
  libraries. The folder structure need to follow the openLCA workspace
  structure, means the sub-folder `databases` of that folder contains the
  database and the sub-folder `libraries` possible data libraries to which
  the database is linked. If this parameter is not provided, the default
  openLCA workspace (currently `~/openLCA-data-1.4`) is taken as data folder.

-db &lt;database&gt;
  The name of the database in the data folder (only the name, not a full
  file path, must be provided); defaults to 'database'.

-port &lt;port&gt;
  The port of the server; defaults to 8080.

-native &lt;path to native library folder&gt;
  The path to the folder from which the native libraries should be
  loaded; defaults to the data folder.

-threads &lt;number of calculation threads&gt;
 	The number of parallel threads that can be used for calculations. Make sure
 	that the server has enough resources if you provide a larger number than 1
 	here; defaults to 1.

-timeout &lt;minutes after which results are disposed&gt;
 	The time in minutes after which results are cleaned up if they were not
 	disposed by the user. A value of &lt;=0 means that no timeout should be
 	applied; defaults to 0.

--readonly &lt;true | false&gt;?
  If this flag is set, the server will run in readonly mode and modifying the
  database will not be possible.

-static &lt;path to folder with static files&gt;
  A path to a folder with static files that should be hosted by the server.
  This only has an effect if the server supports hosting of static files.

</code></pre>
<h2 id="startup-scripts-in-openlca"><a class="header" href="#startup-scripts-in-openlca">Startup scripts in openLCA</a></h2>
<p>In the <code>bin</code> folder of the openLCA application, there are two scripts for
starting a headless IPC server (without user interface involved):</p>
<ul>
<li><code>ipc-server</code>: for JSON-RPC based IPC servers</li>
<li><code>grpc-server</code>: for gRPC based IPC servers</li>
</ul>
<p>These scripts just take the name of a database in the default openLCA workspace
as argument and will start a server at port <code>8080</code>. For example, for Windows
starting a headless IPC server for the database <code>ecoinvent39</code> looks like this:</p>
<pre><code class="language-batch">cd openLCA\bin
.\ipc-server.cmd ecoinvent39
</code></pre>
<p>A running server can be quit with <code>Ctr+c</code>. <strong>Note</strong> that you cannot connect to a
database that is opened via the openLCA desktop application with a headless
server. You can of course modify these scripts to your needs or re-package a
server application under the respective license conditions.</p>
<h2 id="running-with-docker"><a class="header" href="#running-with-docker">Running with Docker</a></h2>
<p>An IPC server can be of course also packaged as a Docker container and the
<a href="https://github.com/GreenDelta/gdt-server">gdt-server</a> is especially useful for
this. There are basically two types of gdt-server images: images with packaged
LCA models (<em>model images</em>) and images without a model (<em>service images</em>).</p>
<h3 id="model-images"><a class="header" href="#model-images">Model images</a></h3>
<p>A model image is an easy way to distribute and share one or more computable LCA
models. Such models are often parameterized and can be calculated for a given
set of parameter values on demand. Model images are typically shared as tar
archives which can be loaded into a local image repository via the <code>load</code>
command:</p>
<pre><code class="language-bash">docker load -i gdt-server-{identifier}.tar
</code></pre>
<p>With <code>docker image ls</code> you should see the image then. A model image typically
does not need any configuration (timeouts, number of threads etc.), you just
run it and map the <code>8080</code> port of openLCA service in the container (note that
<code>-d</code> runs the container in detached mode, <code>--rm</code> will delete it when it is
stopped):</p>
<pre><code class="language-bash">docker run -p 3000:8080 -d --rm gdt-server-{identifier}
</code></pre>
<p>In the example above, it maps the port <code>8080</code> in the container to the port
<code>3000</code>, the URL <code>http://localhost:3000/api/version</code> should then respond with the
API version of the gdt-server.</p>
<h3 id="service-images"><a class="header" href="#service-images">Service images</a></h3>
<p>A service image contains a gdt-server and can be configured via start parameters
of a container. The components of such a service image are freely available in
the Github container registry and can be composed via <a href="https://github.com/GreenDelta/gdt-server/blob/main/Dockerfile">this
Dockerfile</a>,
e.g.:</p>
<pre><code class="language-bash">cd &lt;workdir&gt;
curl https://raw.githubusercontent.com/GreenDelta/gdt-server/main/Dockerfile \
  &gt; Dockerfile \
  &amp;&amp; docker build -t gdt-server .
</code></pre>
<p>A container can be started from such an image in the following way:</p>
<pre><code class="language-bash">docker run \
  -p 3000:8080 \
  -v $HOME/openLCA-data-1.4:/app/data \
  --rm -d gdt-server \
  -db example --readonly
</code></pre>
<p>As above, it first maps the internal port to the port <code>3000</code> of the host. Also,
a data folder needs to be mounted under the <code>/app/data</code> folder of the container.
In this example, it maps the default openLCA workspace to that folder. More
configuration parameters can be passed to the server via the start command of
the container.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-ipc---from-scratch"><a class="header" href="#python-ipc---from-scratch">Python IPC - From scratch</a></h1>
<p>In this section we will go through a complete example using the openLCA IPC
interface from the <a href="https://github.com/GreenDelta/olca-ipc.py">olca-ipc.py</a>
Python package. As we will create everything from scratch, we first create an
empty database and start an IPC server for that database:</p>
<p><img src="examples/./images/py_scratch_init_db.png" alt="" /></p>
<p>In the Python code, we first import the required packages that we will use in
our example. The <code>olca-schema</code> packages comes is a dependency of the <code>olca-ipc</code>
package and contains the data type definitions of the openLCA model and some
utility methods. We will use Pandas for formatting our data output and NumPy,
which is a dependency of Pandas, for checking the calculation. Also, we will
add type annotations in our code, compatible with Python 3.11.</p>
<pre><code class="language-py">import olca_ipc as ipc
import olca_schema as o
import pandas as pd
import numpy as np

from typing import Callable

</code></pre>
<h2 id="a-historic-example"><a class="header" href="#a-historic-example">A historic example</a></h2>
<p>Our example was taken from <a href="https://www.sciencedirect.com/science/article/abs/pii/0921800994900388">Heijungs
1994</a><sup class="footnote-reference"><a href="#paper">1</a></sup>
and extended a bit. First, we define the technosphere of our system which are
4 processes connected by 4 products:</p>
<pre><code class="language-py">technosphere = pd.DataFrame(
    data=[
        [1.0, -50.0, -1.0, 0.0],
        [-0.01, 1.0, -1.0, 0.0],
        [0.0, 0.0, 1.0, -1.0],
        [0.0, 0.0, 0.0, 100],
    ],
    columns=[
        &quot;electricity production&quot;,
        &quot;aluminium production&quot;,
        &quot;aluminium foil production&quot;,
        &quot;sandwitch package production&quot;,
    ],
    index=[
        &quot;electricity [MJ]&quot;,
        &quot;aluminium [kg]&quot;,
        &quot;aluminium foil [kg]&quot;,
        &quot;sandwitch package [Item(s)]&quot;,
    ],
)
print(technosphere)
</code></pre>
<p>When we print this data frame, we get the following table:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>electricity production</th><th>aluminium production</th><th>aluminium foil production</th><th>sandwitch package production</th></tr></thead><tbody>
<tr><td>electricity [MJ]</td><td>1.00</td><td>-50.0</td><td>-1.0</td><td>0.0</td></tr>
<tr><td>aluminium [kg]</td><td>-0.01</td><td>1.0</td><td>-1.0</td><td>0.0</td></tr>
<tr><td>aluminium foil [kg]</td><td>0.00</td><td>0.0</td><td>1.0</td><td>-1.0</td></tr>
<tr><td>sandwitch package [Item(s)]</td><td>0.00</td><td>0.0</td><td>0.0</td><td>100.0</td></tr>
</tbody></table>
</div>
<p>In the rows, we have our products, in the columns the processes. Inputs have
negative and outputs positive values. Thus, for 100 sandwitch packages, we would
need 1 kg of aluminium foil (this is how sandwitches were packed in the 90s)<sup class="footnote-reference"><a href="#no">2</a></sup>.</p>
<p>Next, we define the interventions of these processes with the environment:</p>
<pre><code class="language-py">interventions = pd.DataFrame(
    data=[
        [0.0, -5.0, 0.0, 0.0],
        [-0.5, 0.0, 0.0, 0.0],
        [3.0, 0.0, 0.0, 0.0],
        [2.0, 10.0, 0.0, 1.0],
    ],
    columns=technosphere.columns,
    index=[
        &quot;bauxite [kg]&quot;,
        &quot;crude oil [kg]&quot;,
        &quot;CO2 [kg]&quot;,
        &quot;solid waste [kg]&quot;,
    ],
)
print(interventions)
</code></pre>
<div class="table-wrapper"><table><thead><tr><th></th><th>electricity production</th><th>aluminium production</th><th>aluminium foil production</th><th>sandwitch package production</th></tr></thead><tbody>
<tr><td>bauxite [kg]</td><td>0.0</td><td>-5.0</td><td>0.0</td><td>0.0</td></tr>
<tr><td>crude oil [kg]</td><td>-0.5</td><td>0.0</td><td>0.0</td><td>0.0</td></tr>
<tr><td>CO2 [kg]</td><td>3.0</td><td>0.0</td><td>0.0</td><td>0.0</td></tr>
<tr><td>solid waste [kg]</td><td>2.0</td><td>10.0</td><td>0.0</td><td>1.0</td></tr>
</tbody></table>
</div>
<p>In the paper, the inventory is calculated for 10 sandwitch packages as the final
demand \(f\) of the system, which we can quickly do with NumPy now:</p>
<pre><code class="language-py">f = [
    0.0,
    0.0,
    0.0,
    10,
]
s = np.linalg.solve(technosphere.to_numpy(), f)
g = interventions.to_numpy() @ s
print(pd.DataFrame(g, index=interventions.index))
</code></pre>
<p>This gives the expected result:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>bauxite [kg]</td><td>-1.01</td></tr>
<tr><td>crude oil [kg]</td><td>-5.10</td></tr>
<tr><td>CO2 [kg]</td><td>30.60</td></tr>
<tr><td>solid waste [kg]</td><td>22.52</td></tr>
</tbody></table>
</div>
<h2 id="inventory-calculations"><a class="header" href="#inventory-calculations">Inventory calculations</a></h2>
<p>Now we do the same in openLCA via the IPC interface. First, we create an IPC
client that holds our connection data:</p>
<pre><code class="language-py">client = ipc.Client(8080)
</code></pre>
<p>As we have nothing in our database, we first need to create the units and flow
properties (quantity kinds) in which the flows of the examples are measured:</p>
<pre><code class="language-py">mass_units = o.new_unit_group(&quot;Mass units&quot;, &quot;kg&quot;)
energy_units = o.new_unit_group(&quot;Energy units&quot;, &quot;MJ&quot;)
counting_units = o.new_unit_group(&quot;Counting units&quot;, &quot;Item(s)&quot;)
mass = o.new_flow_property(&quot;Mass&quot;, mass_units)
energy = o.new_flow_property(&quot;Energy&quot;, energy_units)
count = o.new_flow_property(&quot;Number of items&quot;, counting_units)

client.put_all(
    mass_units,
    energy_units,
    counting_units,
    mass,
    energy,
    count,
)
</code></pre>
<p>While IPC server is running, you can also continue to use the openLCA user
interface, just do not close the dialog of the server. When you refresh the
navigation, you will see the newly created unit groups and flow properties:</p>
<p><img src="examples/./images/py_scratch_units.png" alt="" /></p>
<p>However, typically you will not create units and flow properties but use the
reference data from openLCA. For example, we can get the flow property <code>Mass</code>
by its name:</p>
<pre><code class="language-py">print(client.get(o.FlowProperty, name=&quot;Mass&quot;).to_json())
</code></pre>
<p>This will print the JSON serialization of that flow property which is the
internal communication format of the IPC interface (and also the standard
openLCA data exchange format in general):</p>
<pre><code class="language-json">{
  &quot;@type&quot;: &quot;FlowProperty&quot;,
  &quot;@id&quot;: &quot;b24a123b-f5a1-40fb-a481-afeeb50f6159&quot;,
  &quot;lastChange&quot;: &quot;2023-01-26T13:36:37.954Z&quot;,
  &quot;name&quot;: &quot;Mass&quot;,
  &quot;unitGroup&quot;: {
    &quot;@type&quot;: &quot;UnitGroup&quot;,
    &quot;@id&quot;: &quot;3e912f50-9490-473c-89fc-1393ed2eea03&quot;,
    &quot;name&quot;: &quot;Mass units&quot;
  },
  &quot;version&quot;: &quot;01.00.000&quot;
}
</code></pre>
<p>Next, we create the flows of the example. In the snippet below, it iterates
over the rows of the data frames and creates a product or elementary flow for
each row, extracting the unit from the row label and mapping the corresponding
flow property:</p>
<pre><code class="language-py">def create_flow(
    row_label: str, fn: Callable[[str, o.FlowProperty], o.Flow]
) -&gt; o.Flow:
    parts = row_label.split(&quot;[&quot;)
    name = parts[0].strip()
    unit = parts[1][0:-1].strip()
    match unit:
        case &quot;kg&quot;:
            prop = mass
        case &quot;MJ&quot;:
            prop = energy
        case &quot;Item(s)&quot;:
            prop = count
    flow = fn(name, prop)
    client.put(flow)
    return flow


tech_flows = [create_flow(label, o.new_product) for label in technosphere.index]
envi_flows = [
    create_flow(label, o.new_elementary_flow) for label in interventions.index
]
</code></pre>
<p>Then we iterate over the columns of the data frames and create the corrsponding
processes with their inputs and outputs of the flows we just created. One the
diagonal of the technosphere matrix, the reference products of the respective
processes are located and we set the these exchanges as the quantitative
reference of the corresponding process:</p>
<pre><code class="language-py">def create_process(index: int, name: str) -&gt; o.Process:
    process = o.new_process(name)

    def exchange(flow: o.Flow, value: float) -&gt; o.Exchange | None:
        if value == 0:
            return None
        if value &lt; 0:
            return o.new_input(process, flow, abs(value))
        else:
            return o.new_output(process, flow, value)

    for (i, tech_flow) in enumerate(tech_flows):
        value = technosphere.iat[i, index]
        e = exchange(tech_flow, value)
        if e and i == index:
            e.is_quantitative_reference = True

    for (i, envi_flow) in enumerate(envi_flows):
        value = interventions.iat[i, index]
        exchange(envi_flow, value)

    client.put(process)
    return process


processes = [
    create_process(index, name)
    for (index, name) in enumerate(technosphere.columns)
]
</code></pre>
<p>When you refresh the navigation in openLCA again, you should now see these
new processes and flows:</p>
<p><img src="examples/./images/py_scratch_processes.png" alt="" /></p>
<p>Now we can calculate the inventory of this system. We create a calculation setup
for the sandwitch packaging process as calculation target. We do not need to set
the unit in the setup as it would take the unit of the quantitative reference of
the process by default, but we need to set the amount as we want the result for
10 sandwitches but the process has 100 as quantitative reference. The
calculation immediately returns a result object but this is maybe not ready yet,
so we wait for the calculation to be finished via the <code>wait_until_ready</code>
method:</p>
<pre><code class="language-py">setup = o.CalculationSetup(
    target=o.Ref(ref_type=o.RefType.Process, id=processes[3].id),
    unit=count.unit_group.ref_unit,  # &quot;Item(s)&quot;
    amount=10,
)
result = client.calculate(setup)
result.wait_until_ready()
</code></pre>
<p>When the result is ready, we can query the inventory from it:</p>
<pre><code class="language-py">inventory = result.get_total_flows()
print(
    pd.DataFrame(
        data=[
            (
                i.envi_flow.flow.name,
                i.envi_flow.is_input,
                i.amount,
                i.envi_flow.flow.ref_unit,
            )
            for i in inventory
        ],
        columns=[&quot;Flow&quot;, &quot;Is input?&quot;, &quot;Amount&quot;, &quot;Unit&quot;],
    )
)
</code></pre>
<p>This prints the following expected values:</p>
<pre><code>          Flow  Is input?  Amount Unit
0          CO2      False   30.60   kg
1    crude oil       True    5.10   kg
2  solid waste      False   22.52   kg
3      bauxite       True    1.01   kg
</code></pre>
<p>Finally, when we do not need the result anymore, we need to dispose it so that
allocated resources can be freed on the openLCA side:</p>
<pre><code class="language-py">result.dispose()
</code></pre>
<h2 id="full-workbook"><a class="header" href="#full-workbook">Full workbook</a></h2>
<p>Below is the full example. Note that you can run it as a note-book, cell by
cell, in VS Code:</p>
<pre><code class="language-py"># %%
# ANCHOR: imports
import olca_ipc as ipc
import olca_schema as o
import pandas as pd
import numpy as np

from typing import Callable

# ANCHOR_END: imports


# %%
# ANCHOR: techsphere
technosphere = pd.DataFrame(
    data=[
        [1.0, -50.0, -1.0, 0.0],
        [-0.01, 1.0, -1.0, 0.0],
        [0.0, 0.0, 1.0, -1.0],
        [0.0, 0.0, 0.0, 100],
    ],
    columns=[
        &quot;electricity production&quot;,
        &quot;aluminium production&quot;,
        &quot;aluminium foil production&quot;,
        &quot;sandwitch package production&quot;,
    ],
    index=[
        &quot;electricity [MJ]&quot;,
        &quot;aluminium [kg]&quot;,
        &quot;aluminium foil [kg]&quot;,
        &quot;sandwitch package [Item(s)]&quot;,
    ],
)
print(technosphere)
# ANCHOR_END: techsphere


# %%
# ANCHOR: envisphere
interventions = pd.DataFrame(
    data=[
        [0.0, -5.0, 0.0, 0.0],
        [-0.5, 0.0, 0.0, 0.0],
        [3.0, 0.0, 0.0, 0.0],
        [2.0, 10.0, 0.0, 1.0],
    ],
    columns=technosphere.columns,
    index=[
        &quot;bauxite [kg]&quot;,
        &quot;crude oil [kg]&quot;,
        &quot;CO2 [kg]&quot;,
        &quot;solid waste [kg]&quot;,
    ],
)
print(interventions)
# ANCHOR_END: envisphere


# %%
# ANCHOR: numsol
f = [
    0.0,
    0.0,
    0.0,
    10,
]
s = np.linalg.solve(technosphere.to_numpy(), f)
g = interventions.to_numpy() @ s
print(pd.DataFrame(g, index=interventions.index))
# ANCHOR_END: numsol


# %%
# ANCHOR: mkclient
client = ipc.Client(8080)
# ANCHOR_END: mkclient


# %%
# ANCHOR: units
mass_units = o.new_unit_group(&quot;Mass units&quot;, &quot;kg&quot;)
energy_units = o.new_unit_group(&quot;Energy units&quot;, &quot;MJ&quot;)
counting_units = o.new_unit_group(&quot;Counting units&quot;, &quot;Item(s)&quot;)
mass = o.new_flow_property(&quot;Mass&quot;, mass_units)
energy = o.new_flow_property(&quot;Energy&quot;, energy_units)
count = o.new_flow_property(&quot;Number of items&quot;, counting_units)

client.put_all(
    mass_units,
    energy_units,
    counting_units,
    mass,
    energy,
    count,
)
# ANCHOR_END: units


# %%
# ANCHOR: mass
print(client.get(o.FlowProperty, name=&quot;Mass&quot;).to_json())
# ANCHOR_END: mass


# %%
# ANCHOR: flows
def create_flow(
    row_label: str, fn: Callable[[str, o.FlowProperty], o.Flow]
) -&gt; o.Flow:
    parts = row_label.split(&quot;[&quot;)
    name = parts[0].strip()
    unit = parts[1][0:-1].strip()
    match unit:
        case &quot;kg&quot;:
            prop = mass
        case &quot;MJ&quot;:
            prop = energy
        case &quot;Item(s)&quot;:
            prop = count
    flow = fn(name, prop)
    client.put(flow)
    return flow


tech_flows = [create_flow(label, o.new_product) for label in technosphere.index]
envi_flows = [
    create_flow(label, o.new_elementary_flow) for label in interventions.index
]
# ANCHOR_END: flows


# %%
# ANCHOR: processes
def create_process(index: int, name: str) -&gt; o.Process:
    process = o.new_process(name)

    def exchange(flow: o.Flow, value: float) -&gt; o.Exchange | None:
        if value == 0:
            return None
        if value &lt; 0:
            return o.new_input(process, flow, abs(value))
        else:
            return o.new_output(process, flow, value)

    for (i, tech_flow) in enumerate(tech_flows):
        value = technosphere.iat[i, index]
        e = exchange(tech_flow, value)
        if e and i == index:
            e.is_quantitative_reference = True

    for (i, envi_flow) in enumerate(envi_flows):
        value = interventions.iat[i, index]
        exchange(envi_flow, value)

    client.put(process)
    return process


processes = [
    create_process(index, name)
    for (index, name) in enumerate(technosphere.columns)
]
# ANCHOR_END: processes


# %%
# ANCHOR: calc
setup = o.CalculationSetup(
    target=o.Ref(ref_type=o.RefType.Process, id=processes[3].id),
    unit=count.unit_group.ref_unit,  # &quot;Item(s)&quot;
    amount=10,
)
result = client.calculate(setup)
result.wait_until_ready()
# ANCHOR_END: calc


# %%
# ANCHOR: inventory
inventory = result.get_total_flows()
print(
    pd.DataFrame(
        data=[
            (
                i.envi_flow.flow.name,
                i.envi_flow.is_input,
                i.amount,
                i.envi_flow.flow.ref_unit,
            )
            for i in inventory
        ],
        columns=[&quot;Flow&quot;, &quot;Is input?&quot;, &quot;Amount&quot;, &quot;Unit&quot;],
    )
)
# ANCHOR_END: inventory


# %%
# ANCHOR: free-inventory
result.dispose()
# ANCHOR_END: free-inventory

# %%
</code></pre>
<hr />
<div class="footnote-definition" id="paper"><sup class="footnote-definition-label">1</sup>
<p>Reinout Heijungs: A generic method for the identification of options
for cleaner products. Ecological Economics, Volume 10, Issue 1, 1994, Pages
69-81, ISSN 0921-8009,
<a href="https://www.sciencedirect.com/science/article/abs/pii/0921800994900388">https://doi.org/10.1016/0921-8009(94)90038-8</a>.</p>
</div>
<div class="footnote-definition" id="no"><sup class="footnote-definition-label">2</sup>
<p>it is of course just an illustrative example and not real data</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calculation-parameters"><a class="header" href="#calculation-parameters">Calculation parameters</a></h1>
<p>This example shows the calculation of an LCA model with different parameter
values. We will use the openLCA Python IPC module and the REST API in this
example. First, we need to make sure that the current olca-ipc package is
installed. Currently the <a href="https://pypi.org/project/olca-ipc/#history">latest
version</a> for openLCA 2 is <code>2.0.0a4</code>:</p>
<pre><code>pip install olca-ipc==2.0.0a4
</code></pre>
<p>We connect to a REST API in this example and assume that it is running at
<code>http://192.168.142.136:3000</code></p>
<pre><code class="language-py">import olca_schema as o
import olca_ipc.rest as rest
import json

client = rest.RestClient(&quot;http://192.168.142.136:3000&quot;)
</code></pre>
<p>To check that we can access the server, we can also just call this URL in a
browser: <code>http://192.168.142.136:3000/api/version</code>, which should then return the
API version of that server.</p>
<p>Next, we check which models (product systems) are available and select the
first model for our calculations:</p>
<pre><code class="language-py">models = client.get_descriptors(o.ProductSystem)
for model in models:
    print(f&quot;{model.name} :: {model.id}&quot;)
model = models[0]
</code></pre>
<p>This should print something like this depending on the available models:</p>
<pre><code>battery model without EoL :: 59327d11-9a0d-477b-9cc0-060ca74b6327
battery model with EoL :: eb31db8a-8102-453d-a549-be989e83c592
</code></pre>
<p>Again, we could just query an URL for this, for the example:
<code>http://192.168.142.136:3000/data/product-systems</code></p>
<p>We do the same for the available impact assessment methods (
<code>http://192.168.142.136:3000/data/methods</code>):</p>
<pre><code class="language-py">methods = client.get_descriptors(o.ImpactMethod)
for method in methods:
    print(f&quot;{method.name} :: {method.id}&quot;)
method = methods[0]
</code></pre>
<p>This should print something like this:</p>
<pre><code>EF 3.0 Method (adapted) :: b4571628-4b7b-3e4f-81b1-9a8cca6cb3f8
...
</code></pre>
<p>With the reference to a product system and LCIA method, we can create a
calculation setup:</p>
<pre><code class="language-py">setup = o.CalculationSetup(
    target=model,
    impact_method=method,
)
print(json.dumps(setup.to_dict(), indent=2))
</code></pre>
<p>The objects of the openLCA schema can be easily translated to JSON as done
in the snippet above. This is the payload that is posted to the server in a
<a href="examples/../results/calculate.html">calculation request</a>:</p>
<pre><code class="language-json">{
  &quot;impactMethod&quot;: {
    &quot;@type&quot;: &quot;ImpactMethod&quot;,
    &quot;@id&quot;: &quot;b4571628-4b7b-3e4f-81b1-9a8cca6cb3f8&quot;,
    &quot;category&quot;: &quot;openLCA LCIA methods 2_1_2&quot;,
    &quot;name&quot;: &quot;EF 3.0 Method (adapted)&quot;
  },
  &quot;target&quot;: {
    &quot;@type&quot;: &quot;ProductSystem&quot;,
    &quot;@id&quot;: &quot;59327d11-9a0d-477b-9cc0-060ca74b6327&quot;,
    &quot;name&quot;: &quot;battery model without EoL&quot;
  }
}
</code></pre>
<p>We can calculate the setup like this:</p>
<pre><code class="language-py">result = client.calculate(setup)
result.wait_until_ready()
impacts = result.get_total_impacts()
for i in impacts:
    assert i.impact_category
    print(f&quot;{i.impact_category.name} {i.amount} {i.impact_category.ref_unit}&quot;)
result.dispose()
</code></pre>
<p>As shown above, we should dispose a result when we do not need it anymore. The
snippet prints something like:</p>
<pre><code>...
Climate change 0.7891638059816873 kg CO2 eq
...
</code></pre>
<p>For parameterized models, the default parameter values are applied in a
calculation but we can change them in each calculation. We can query the
parameters of a model like this:</p>
<pre><code class="language-py">parameters = client.get_parameters(o.ProductSystem, model.id)
for param in parameters:
    print(f&quot;parameter: {param.name} = {param.value}&quot;)
param = parameters[0]
</code></pre>
<p>For our example, we just have a single parameter, <code>number_of_recharges</code> with
a default value of <code>1.0</code>:</p>
<pre><code>parameter: number_of_recharges = 1.0
</code></pre>
<p>The corresponding URL is:
<code>http://192.168.142.136:3000/data/product-systems/59327d11-9a0d-477b-9cc0-060ca74b6327/parameters</code></p>
<p>Finally, we run a set of calculations over a parameter range:</p>
<pre><code class="language-py">for x in range(0, 55, 5):
    setup = o.CalculationSetup(
        target=model,
        impact_method=method,
        parameters=[
            o.ParameterRedef(name=param.name, value=x, context=param.context)
        ],
    )
    result = client.calculate(setup)
    assert result
    result.wait_until_ready()
    impacts = result.get_total_impacts()
    for i in impacts:
        if i.impact_category.name == &quot;Climate change&quot;:
            print(f&quot;{param.name}: {x} =&gt; {i.amount : .3f} kg CO2 eq&quot;)
    result.dispose()
</code></pre>
<p>For the example, it prints something like this:</p>
<pre><code>number_of_recharges: 0 =&gt;  0.788 kg CO2 eq
number_of_recharges: 5 =&gt;  0.792 kg CO2 eq
number_of_recharges: 10 =&gt;  0.796 kg CO2 eq
number_of_recharges: 15 =&gt;  0.800 kg CO2 eq
number_of_recharges: 20 =&gt;  0.803 kg CO2 eq
number_of_recharges: 25 =&gt;  0.807 kg CO2 eq
number_of_recharges: 30 =&gt;  0.811 kg CO2 eq
number_of_recharges: 35 =&gt;  0.814 kg CO2 eq
number_of_recharges: 40 =&gt;  0.818 kg CO2 eq
number_of_recharges: 45 =&gt;  0.822 kg CO2 eq
number_of_recharges: 50 =&gt;  0.826 kg CO2 eq
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-management"><a class="header" href="#data-management">Data management</a></h1>
<p>The openLCA IPC protocol is based on the <a href="http://greendelta.github.io/olca-schema/">openLCA Schema</a> as data exchange format. Thus, parameter and return types of this documentation often link to their respective description in the openLCA schema documentation. The openLCA schema is a typed data format with the following <a href="http://greendelta.github.io/olca-schema/#format-concepts">principles</a>:</p>
<ul>
<li>There are stand-alone entities like processes or flows, called <em>root entities</em>, and composition entities that can only exist within another entity, like the inputs and outputs (called <em>exchanges</em>) of a process.</li>
<li>There is a uniform reference concept in the format: if an entity <code>A</code> references an entity <code>B</code> it only stores a reference to <code>B</code> that is of type <a href="http://greendelta.github.io/olca-schema/classes/Ref.html">Ref</a>. This reference contains the type (if it cannot be inferred from field in <code>A</code>), the ID, and some optional meta-data of <code>B</code>.</li>
</ul>
<pre><code>    +---+   Ref   +---+
    | A |  ----&gt;  | B |
    +---+         +---+
</code></pre>
<p>For example, an output in a process is of type <a href="http://greendelta.github.io/olca-schema/classes/Ref.html">Exchange</a> and an exchange contains a reference to a flow. In addition, instances of the <code>Ref</code> type are often used as data set descriptors: instead of loading the full data set it is often enough to just display some meta-data of an entity (for example in search results).</p>
<p>Many of the data management functions are the same for all root entity types.
Thus, the respective type is often just an additional parameter of a method call.
The table below shows the root entity types and their parameter value in the
Rest API (multiple values can map to the same type for convenience):</p>
<div class="table-wrapper"><table><thead><tr><th>Root entity type</th><th>Rest parameter</th></tr></thead><tbody>
<tr><td><a href="https://greendelta.github.io/olca-schema/classes/Actor.html">Actor</a></td><td><code>actor</code>,  <code>actors</code></td></tr>
<tr><td><a href="https://greendelta.github.io/olca-schema/classes/Category.html">Category</a></td><td><code>category</code>,  <code>categories</code></td></tr>
<tr><td><a href="https://greendelta.github.io/olca-schema/classes/Currency.html">Currency</a></td><td><code>currency</code>,  <code>currencies</code></td></tr>
<tr><td><a href="https://greendelta.github.io/olca-schema/classes/DQSystem.html">DQSystem</a></td><td><code>dq-system</code>,  <code>dq-systems</code></td></tr>
<tr><td><a href="https://greendelta.github.io/olca-schema/classes/Epd.html">Epd</a></td><td><code>epd</code>,  <code>epds</code></td></tr>
<tr><td><a href="https://greendelta.github.io/olca-schema/classes/Flow.html">Flow</a></td><td><code>flow</code>,  <code>flows</code></td></tr>
<tr><td><a href="https://greendelta.github.io/olca-schema/classes/FlowProperty.html">FlowProperty</a></td><td><code>flow-property</code>,  <code>flow-properties</code></td></tr>
<tr><td><a href="https://greendelta.github.io/olca-schema/classes/ImpactCategory.html">ImpactCategory</a></td><td><code>impact-category</code>,  <code>impact-categories</code></td></tr>
<tr><td><a href="https://greendelta.github.io/olca-schema/classes/ImpactMethod.html">ImpactMethod</a></td><td><code>impact-method</code>,  <code>method</code>,  <code>impact-methods</code>,  <code>methods</code></td></tr>
<tr><td><a href="https://greendelta.github.io/olca-schema/classes/Location.html">Location</a></td><td><code>location</code>,  <code>locations</code></td></tr>
<tr><td><a href="https://greendelta.github.io/olca-schema/classes/Parameter.html">Parameter</a></td><td><code>parameter</code>,  <code>parameters</code></td></tr>
<tr><td><a href="https://greendelta.github.io/olca-schema/classes/Process.html">Process</a></td><td><code>process</code>,  <code>processes</code></td></tr>
<tr><td><a href="https://greendelta.github.io/olca-schema/classes/ProductSystem.html">ProductSystem</a></td><td><code>product-system</code>, <code>product-systems</code>, <code>model</code>, <code>models</code></td></tr>
<tr><td><a href="https://greendelta.github.io/olca-schema/classes/Project.html">Project</a></td><td><code>project</code>,  <code>projects</code></td></tr>
<tr><td><a href="https://greendelta.github.io/olca-schema/classes/Result.html">Result</a></td><td><code>result</code>,  <code>results</code></td></tr>
<tr><td><a href="https://greendelta.github.io/olca-schema/classes/SocialIndicator.html">SocialIndicator</a></td><td><code>social-indicator</code>,  <code>social-indicators</code></td></tr>
<tr><td><a href="https://greendelta.github.io/olca-schema/classes/Source.html">Source</a></td><td><code>source</code>,  <code>sources</code></td></tr>
<tr><td><a href="https://greendelta.github.io/olca-schema/classes/UnitGroup.html">UnitGroup</a></td><td><code>unit-group</code>,  <code>unit-groups</code></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="get-descriptors"><a class="header" href="#get-descriptors">Get descriptors</a></h1>
<p>This function is useful for exploring the content of a database. It returns a
list of data set descriptors for a given data set type. A descriptor contains
just a few information, like the name or category path, to understand the
content of a data set. Descriptors are valid <a href="https://greendelta.github.io/olca-schema/classes/Ref.html">data set
references</a>; they can
be used to reference a data set in a given context (e.g. referencing a process
as calculation target in a calculation setup).</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Rest API</td><td><code>GET /data/{type}</code></td></tr>
<tr><td>JSON-RPC</td><td><code>data/get/descriptors</code></td></tr>
<tr><td>Python/IPC</td><td><code>Client.get_descriptors</code></td></tr>
<tr><td>Return type</td><td><a href="https://greendelta.github.io/olca-schema/classes/Ref.html"><code>List[Ref]</code></a></td></tr>
</tbody></table>
</div>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<h3 id="python-ipc"><a class="header" href="#python-ipc">Python IPC</a></h3>
<pre><code class="language-py">import olca_ipc as ipc
import olca_schema as o

client = ipc.Client()
refs = client.get_descriptors(o.FlowProperty)
for ref in refs:
    print(ref.name)
# Area
# Area*time
# Duration
# Energy
</code></pre>
<h3 id="json-rpc-via-fetch-api"><a class="header" href="#json-rpc-via-fetch-api">JSON-RPC via Fetch API</a></h3>
<p>The example below shows the usage of this method using the JSON-RPC protocol via
the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>
which is available in modern web-browsers or platforms like
<a href="https://deno.land/">Deno</a>.</p>
<pre><code class="language-ts">  let resp = await fetch(&quot;http://localhost:8080&quot;, {
    method: &quot;POST&quot;,
    body: JSON.stringify({
      jsonrpc: &quot;2.0&quot;,
      id: 1,
      method: &quot;data/get/descriptors&quot;,
      params: {
        &quot;@type&quot;: &quot;FlowProperty&quot;
      }
    })
  });
  let descriptors = await resp.json();
  console.log(descriptors);
  // {
  //   jsonrpc: &quot;2.0&quot;,
  //   id: 1,
  //   result: [
  //     {
  //       &quot;@type&quot;: &quot;FlowProperty&quot;,
  //       &quot;@id&quot;: &quot;838aaa20-0117-11db-92e3-0800200c9a66&quot;,
  //       name: &quot;Goods transport (mass*distance)&quot;,
  //       category: &quot;Technical flow properties&quot;,
  //       refUnit: &quot;t*km&quot;
  //     },
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get-a-full-data-set-by-id"><a class="header" href="#get-a-full-data-set-by-id">Get a full data set by ID</a></h1>
<p>This method returns the full data set of a given type and ID.</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Rest API</td><td><code>GET /data/{type}/{id}</code></td></tr>
<tr><td>JSON-RPC</td><td><code>data/get</code></td></tr>
<tr><td>Python/IPC</td><td><code>Client.get</code></td></tr>
<tr><td>Return type</td><td><a href="https://greendelta.github.io/olca-schema/classes/RootEntity.html"><code>E &gt; RootEntity</code></a></td></tr>
</tbody></table>
</div>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<h3 id="python-ipc-1"><a class="header" href="#python-ipc-1">Python IPC</a></h3>
<pre><code class="language-py">import olca_ipc as ipc
import olca_schema as o

client = ipc.Client()
process = client.get(o.Process, &quot;eacc4872-6f4e-4ff1-946e-c1bddeda24be&quot;)
print(process)
# Process(
#   id='eacc4872-6f4e-4ff1-946e-c1bddeda24be',
#   exchanges=[Exchange(amount=1.0, flow=Ref(id='b254bbdf- ...
</code></pre>
<h3 id="json-rpc-via-fetch-api-1"><a class="header" href="#json-rpc-via-fetch-api-1">JSON-RPC via Fetch API</a></h3>
<p>The example below shows the usage of this method using the JSON-RPC protocol via
the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>
which is available in modern web-browsers or platforms like
<a href="https://deno.land/">Deno</a>.</p>
<pre><code class="language-ts">  let resp = await fetch(&quot;http://localhost:8080&quot;, {
    method: &quot;POST&quot;,
    body: JSON.stringify({
      jsonrpc: &quot;2.0&quot;,
      id: 1,
      method: &quot;data/get&quot;,
      params: {
        &quot;@type&quot;: &quot;Process&quot;,
        &quot;@id&quot;: &quot;eacc4872-6f4e-4ff1-946e-c1bddeda24be&quot;
      }
    })
  });
  let v = await resp.json();
  console.log(v);
  // {
  //   jsonrpc: &quot;2.0&quot;,
  //   result: {
  //     &quot;@type&quot;: &quot;Process&quot;,
  //     &quot;@id&quot;: &quot;eacc4872-6f4e-4ff1-946e-c1bddeda24be&quot;,
  //     name: &quot;blast furnace gas, Recycled Content cut-off&quot;,
  //     processType: &quot;LCI_RESULT&quot;,
</code></pre>
<h3 id="curl"><a class="header" href="#curl">Curl</a></h3>
<pre><code class="language-bash">endpoint=&quot;http://localhost:8080&quot;
process_id=&quot;eacc4872-6f4e-4ff1-946e-c1bddeda24be&quot;

curl &quot;$endpoint/data/process/$process_id&quot;
# { &quot;@type&quot;:&quot;Process&quot;,
#   &quot;@id&quot;:&quot;eacc4872-6f4e-4ff1-946e-c1bddeda24be&quot;,
#   &quot;name&quot;:&quot;blast furnace gas, Recycled Content cut-off
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get-a-full-data-set-by-name"><a class="header" href="#get-a-full-data-set-by-name">Get a full data set by name</a></h1>
<p>This method returns a full data set for the given type and name. Note that the
name does not have to be unique in an openLCA database, and in this case, it
will just return the first entity from the database with the given name.</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Rest API</td><td><code>GET /data/{type}/name/{name}</code></td></tr>
<tr><td>JSON-RPC</td><td><code>data/get</code></td></tr>
<tr><td>Python/IPC</td><td><code>Client.get</code></td></tr>
<tr><td>Return type:</td><td><a href="https://greendelta.github.io/olca-schema/classes/RootEntity.html"><code>E &gt; RootEntity</code></a></td></tr>
</tbody></table>
</div>
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<h3 id="python-ipc-2"><a class="header" href="#python-ipc-2">Python IPC</a></h3>
<pre><code class="language-py">import olca_ipc as ipc
import olca_schema as o

client = ipc.Client()
mass = client.get(o.FlowProperty, name=&quot;Mass&quot;)
print(mass)
# FlowProperty(
#   name='Mass',
#   id='93a60a56-a3c8-11da-a746-0800200b9a66',
#   unit_group=Ref(id='93a60a57-a4c8-11da-a746-0800200c9a66', ...
</code></pre>
<h3 id="json-rpc-via-fetch-api-2"><a class="header" href="#json-rpc-via-fetch-api-2">JSON-RPC via Fetch API</a></h3>
<p>The example below shows the usage of this method using the JSON-RPC protocol via
the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>
which is available in modern web-browsers or platforms like
<a href="https://deno.land/">Deno</a>.</p>
<pre><code class="language-ts">  let resp = await fetch(&quot;http://localhost:8080&quot;, {
    method: &quot;POST&quot;,
    body: JSON.stringify({
      jsonrpc: &quot;2.0&quot;,
      id: 1,
      method: &quot;data/get&quot;,
      params: {
        &quot;@type&quot;: &quot;FlowProperty&quot;,
        &quot;name&quot;: &quot;Mass&quot;,
      }
    })
  });
  let v = await resp.json();
  console.log(v);
  // {
  //   jsonrpc: &quot;2.0&quot;,
  //   result: {
  //     &quot;@type&quot;: &quot;FlowProperty&quot;,
  //     &quot;@id&quot;: &quot;93a60a56-a3c8-11da-a746-0800200b9a66&quot;,
  //     name: &quot;Mass&quot;,
  //     category: &quot;Technical flow properties&quot;,
  //     version: &quot;00.00.000&quot;,
  //     flowPropertyType: &quot;PHYSICAL_QUANTITY&quot;,
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get-the-descriptor-of-a-data-set"><a class="header" href="#get-the-descriptor-of-a-data-set">Get the descriptor of a data set</a></h1>
<p>Returns the descriptor of the data set with the given type and ID.</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Rest API</td><td><code>GET /data/{type}/{id}/info</code></td></tr>
<tr><td>JSON-RPC</td><td><code>data/get/descriptor</code></td></tr>
<tr><td>Python/IPC</td><td><code>Client.get_descriptor</code></td></tr>
<tr><td>Return type:</td><td><a href="https://greendelta.github.io/olca-schema/classes/Ref.html"><code>Ref</code></a></td></tr>
</tbody></table>
</div>
<h2 id="examples-4"><a class="header" href="#examples-4">Examples</a></h2>
<h3 id="python-ipc-3"><a class="header" href="#python-ipc-3">Python IPC</a></h3>
<pre><code class="language-py">import olca_ipc as ipc
import olca_schema as o

client = ipc.Client()
mass_ref = client.get_descriptor(o.FlowProperty, name=&quot;Mass&quot;)
print(mass_ref)
# Ref(
#   id='93a60a56-a3c8-11da-a746-0800200b9a66',
#   category='Technical flow properties',
#   name='Mass',
# ...
</code></pre>
<h3 id="json-rpc-via-fetch-api-3"><a class="header" href="#json-rpc-via-fetch-api-3">JSON-RPC via Fetch API</a></h3>
<p>The example below shows the usage of this method using the JSON-RPC protocol via
the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>
which is available in modern web-browsers or platforms like
<a href="https://deno.land/">Deno</a>.</p>
<pre><code class="language-ts">  let resp = await fetch(&quot;http://localhost:8080&quot;, {
    method: &quot;POST&quot;,
    body: JSON.stringify({
      jsonrpc: &quot;2.0&quot;,
      id: 1,
      method: &quot;data/get/descriptor&quot;,
      params: {
        &quot;@type&quot;: &quot;Process&quot;,
        &quot;@id&quot;: &quot;eacc4872-6f4e-4ff1-946e-c1bddeda24be&quot;,
      }
    })
  });
  let v = await resp.json();
  console.log(v);
  // {
  //   jsonrpc: &quot;2.0&quot;,
  //   id: 1,
  //   result: {
  //     &quot;@type&quot;: &quot;Process&quot;,
  //     &quot;@id&quot;: &quot;eacc4872-6f4e-4ff1-946e-c1bddeda24be&quot;,
  //     name: &quot;blast furnace gas, Recycled Content cut-off&quot;,
  //     processType: &quot;LCI_RESULT&quot;,
  //     flowType: &quot;PRODUCT_FLOW&quot;
  //   }
  // }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get-all-data-sets-of-a-given-type"><a class="header" href="#get-all-data-sets-of-a-given-type">Get all data sets of a given type</a></h1>
<p>Returns all data sets of a given type from a database. This is not a practical
method for all types of data sets and may is not available in a specific
context. For example, it is fine to get all unit groups but a server would
go down when you query for all processes in a large database. Typically, you
just want to query all descriptors of a data set type.</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Rest API</td><td><code>GET /data/{type}/all</code></td></tr>
<tr><td>JSON-RPC</td><td><code>data/get/all</code></td></tr>
<tr><td>Python IPC</td><td><code>Client.get_all</code></td></tr>
<tr><td>Return type:</td><td><a href="https://greendelta.github.io/olca-schema/classes/RootEntity.html"><code>List[E &gt; RootEntity]</code></a></td></tr>
</tbody></table>
</div>
<h2 id="examples-5"><a class="header" href="#examples-5">Examples</a></h2>
<h3 id="python-ipc-4"><a class="header" href="#python-ipc-4">Python IPC</a></h3>
<pre><code class="language-py">import olca_ipc as ipc
import olca_schema as o

client = ipc.Client()
for group in client.get_all(o.UnitGroup):
    print(group.name)
# Units of area
# Units of energy
# Units of length
# Units of mass
# ...
</code></pre>
<h3 id="json-rpc-via-fetch-api-4"><a class="header" href="#json-rpc-via-fetch-api-4">JSON-RPC via Fetch API</a></h3>
<p>The example below shows the usage of this method using the JSON-RPC protocol via
the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>
which is available in modern web-browsers or platforms like
<a href="https://deno.land/">Deno</a>.</p>
<pre><code class="language-ts">  let resp = await fetch(&quot;http://localhost:8080&quot;, {
    method: &quot;POST&quot;,
    body: JSON.stringify({
      jsonrpc: &quot;2.0&quot;,
      id: 1,
      method: &quot;data/get/all&quot;,
      params: {
        &quot;@type&quot;: &quot;UnitGroup&quot;
      }
    })
  });
  let v = await resp.json();
  console.log(v);
  // {
  //   jsonrpc: &quot;2.0&quot;,
  //   result: [
  //     {
  //       &quot;@type&quot;: &quot;UnitGroup&quot;,
  //       &quot;@id&quot;: &quot;838aaa21-0117-11db-92e3-0800200c9a66&quot;,
  //       name: &quot;Units of mass*length&quot;,
  //       category: &quot;Technical unit groups&quot;,
  //       version: &quot;00.00.000&quot;,
  //       defaultFlowProperty: {
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get-the-parameters-of-a-data-set"><a class="header" href="#get-the-parameters-of-a-data-set">Get the parameters of a data set</a></h1>
<p>Returns the (local) parameters of the specified data set. In case of processes
and impact categories, a list of parameters is returned. For product systems,
the respective parameter redefinitions are returned.</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Rest API</td><td><code>GET /data/{type}/{id}/parameters</code></td></tr>
<tr><td>JSON-RPC</td><td><code>data/get/parameters</code></td></tr>
<tr><td>Python/IPC</td><td><code>Client.get_parameters</code></td></tr>
<tr><td>Return type</td><td>*</td></tr>
</tbody></table>
</div>
<p>*Return type:</p>
<ul>
<li><a href="https://greendelta.github.io/olca-schema/classes/Parameter.html"><code>List[Parameter]</code></a>
for processes and impact categories</li>
<li><a href="https://greendelta.github.io/olca-schema/classes/ParameterRedef.html"><code>List[ParameterRedef]</code></a>
for product systems</li>
</ul>
<h2 id="examples-6"><a class="header" href="#examples-6">Examples</a></h2>
<h3 id="python-ipc-5"><a class="header" href="#python-ipc-5">Python IPC</a></h3>
<pre><code class="language-py">import olca_ipc as ipc
import olca_schema as o

client = ipc.Client()
params = client.get_parameters(
    o.ProductSystem, &quot;0db1eda6-a34e-4c82-b06b-19f27c92495a&quot;
)
for p in params:
    print(f&quot;{p.name}: {p.value}&quot;)
# param1: 42
# param2: 21
# ...
</code></pre>
<h3 id="json-rpc-via-fetch-api-5"><a class="header" href="#json-rpc-via-fetch-api-5">JSON-RPC via Fetch API</a></h3>
<p>The example below shows the usage of this method using the JSON-RPC protocol via
the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>
which is available in modern web-browsers or platforms like
<a href="https://deno.land/">Deno</a>.</p>
<pre><code class="language-ts">  let resp = await fetch(&quot;http://localhost:8080&quot;, {
    method: &quot;POST&quot;,
    body: JSON.stringify({
      jsonrpc: &quot;2.0&quot;,
      id: 1,
      method: &quot;data/get/parameters&quot;,
      params: {
        &quot;@type&quot;: &quot;ProductSystem&quot;,
        &quot;@id&quot;: &quot;0db1eda6-a34e-4c82-b06b-19f27c92495a&quot;,
      }
    })
  });
  let v = await resp.json();
  console.log(v);
  // {
  //   jsonrpc: &quot;2.0&quot;,
  //   result: [
  //     { name: &quot;param_a&quot;, value: 994, isProtected: false },
  //     { name: &quot;param_b&quot;, value: 0.7237, isProtected: false },
  //     { name: &quot;param_c&quot;, value: 0, isProtected: false },
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get-providers-of-technosphere-flows"><a class="header" href="#get-providers-of-technosphere-flows">Get providers of technosphere flows</a></h1>
<p>Technosphere flows are products or waste flows that can be linked in a product
system model. For products, the providers are processes that produce this
product as output. For waste flows, providers are waste treatment processes
with an input of that waste flow. These provider and flow pairs can be linked
to product inputs and waste outputs of other processes in a product system.</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Rest API</td><td><code>GET /data/providers</code></td></tr>
<tr><td>JSON-RPC</td><td><code>data/get/providers</code></td></tr>
<tr><td>Python IPC</td><td><code>Client.get_providers</code></td></tr>
<tr><td>Return type:</td><td><a href="https://greendelta.github.io/olca-schema/classes/TechFlow.html"><code>List[TechFlow]</code></a></td></tr>
</tbody></table>
</div>
<h2 id="examples-7"><a class="header" href="#examples-7">Examples</a></h2>
<h3 id="python-ipc-6"><a class="header" href="#python-ipc-6">Python IPC</a></h3>
<pre><code class="language-py">import olca_ipc as ipc

client = ipc.Client()
for p in client.get_providers()[:5]:
    print(p)
# TechFlow(
#   provider=Ref(id='71dab7ae-4d58-4f73-8449-5967c296bcde', ...
#   flow=Ref(id='7f6bb533-2d3c-43a6-ac60-6eef299d7c52', ...
</code></pre>
<h3 id="json-rpc-via-fetch-api-6"><a class="header" href="#json-rpc-via-fetch-api-6">JSON-RPC via Fetch API</a></h3>
<p>The example below shows the usage of this method using the JSON-RPC protocol via
the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>
which is available in modern web-browsers or platforms like
<a href="https://deno.land/">Deno</a>.</p>
<pre><code class="language-ts">  let resp = await fetch(&quot;http://localhost:8080&quot;, {
    method: &quot;POST&quot;,
    body: JSON.stringify({
      jsonrpc: &quot;2.0&quot;,
      id: 1,
      method: &quot;data/get/providers&quot;,
    })
  });
  let v = await resp.json();
  console.log(v);
  // {
  //   jsonrpc: &quot;2.0&quot;,
  //   result: [
  //     {
  //       provider: {
  //         &quot;@type&quot;: &quot;Process&quot;,
  //         &quot;@id&quot;: &quot;ba98a130-d92c-4c40-8fe9-c8cab5b956ab&quot;,
  //         name: &quot;electricity production, wind, 1-3MW turbine, onshore&quot;,
  //         processType: &quot;LCI_RESULT&quot;,
  //         flowType: &quot;PRODUCT_FLOW&quot;
  //       },
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get-providers-for-a-flow"><a class="header" href="#get-providers-for-a-flow">Get providers for a flow</a></h1>
<p>This method returns the processes that produce a given product (as output) or
provide the treatment of a given waste flow (as input). Thus, the flow parameter
of this method needs to be a product or waste flow (or an ID of that flow). The
returned providers can be linked to respective product inputs or waste outputs
of other processes in a product system.</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Rest API</td><td><code>GET /data/providers/{flow-id}</code></td></tr>
<tr><td>JSON-RPC</td><td><code>data/get/providers</code></td></tr>
<tr><td>Python IPC</td><td><code>Client.get_providers</code></td></tr>
<tr><td>Return type:</td><td><a href="https://greendelta.github.io/olca-schema/classes/TechFlow.html"><code>List[TechFlow]</code></a></td></tr>
</tbody></table>
</div>
<h2 id="examples-8"><a class="header" href="#examples-8">Examples</a></h2>
<h3 id="python-ipc-7"><a class="header" href="#python-ipc-7">Python IPC</a></h3>
<pre><code class="language-py">import olca_ipc as ipc
import olca_schema as o

client = ipc.Client()
providers = client.get_providers(
    flow=o.Ref(id=&quot;7f6bb533-2d3c-43a6-ac60-6eef299d7c52&quot;)
)
for p in providers:
    print(p)
# TechFlow(
#   provider=Ref(id='71dab7ae-4d58-4f73-8449-5967c296bcde', ...
#   flow=Ref(id='7f6bb533-2d3c-43a6-ac60-6eef299d7c52', ...
</code></pre>
<h3 id="json-rpc-via-fetch-api-7"><a class="header" href="#json-rpc-via-fetch-api-7">JSON-RPC via Fetch API</a></h3>
<p>The example below shows the usage of this method using the JSON-RPC protocol via
the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>
which is available in modern web-browsers or platforms like
<a href="https://deno.land/">Deno</a>.</p>
<pre><code class="language-ts">  let resp = await fetch(&quot;http://localhost:8080&quot;, {
    method: &quot;POST&quot;,
    body: JSON.stringify({
      jsonrpc: &quot;2.0&quot;,
      id: 1,
      method: &quot;data/get/providers&quot;,
      params: {
        // only the ID is required here
        &quot;@type&quot;: &quot;Flow&quot;,
        &quot;@id&quot;: &quot;66c93e71-f32b-4591-901c-55395db5c132&quot;,
        name: &quot;electricity, high voltage&quot;
      }
    })
  });
  let v = await resp.json();
  console.log(v);
  // {
  //   jsonrpc: &quot;2.0&quot;,
  //   result: [
  //     {
  //       provider: {
  //         &quot;@type&quot;: &quot;Process&quot;,
  //         &quot;@id&quot;: &quot;ba98a130-d92c-4c40-8fe9-c8cab5b956ab&quot;,
  //         name: &quot;electricity production, wind, 1-3MW turbine, onshore&quot;,
  //         processType: &quot;LCI_RESULT&quot;,
  //         flowType: &quot;PRODUCT_FLOW&quot;
  //       },
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="insert-or-update-a-data-set"><a class="header" href="#insert-or-update-a-data-set">Insert or update a data set</a></h1>
<p>Inserts or updates a provided data set in the database. This method is not
available when a server runs in read-only mode.</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Rest API</td><td><code>PUT /data/{type}</code></td></tr>
<tr><td>JSON-RPC</td><td><code>data/put</code></td></tr>
<tr><td>Python/IPC</td><td><code>client.put</code></td></tr>
<tr><td>Request body</td><td><a href="https://greendelta.github.io/olca-schema/classes/RootEntity.html"><code>E &gt; RootEntity</code></a></td></tr>
<tr><td>Return type:</td><td><a href="https://greendelta.github.io/olca-schema/classes/Ref.html"><code>Ref</code></a></td></tr>
</tbody></table>
</div>
<h2 id="examples-9"><a class="header" href="#examples-9">Examples</a></h2>
<h3 id="python-ipc-8"><a class="header" href="#python-ipc-8">Python IPC</a></h3>
<pre><code class="language-py">import olca_ipc as ipc
import olca_schema as o

client = ipc.Client()
ref = client.put(o.Source(name=&quot;Inter-process communication with openLCA&quot;))
print(ref)
# Ref(
#  id=&quot;16cba9b2-2987-4735-9f3e-96fedf8449dd&quot;,
#  name=&quot;Inter-process communication with openLCA&quot;,
# ...
</code></pre>
<h3 id="json-rpc-via-fetch-api-8"><a class="header" href="#json-rpc-via-fetch-api-8">JSON-RPC via Fetch API</a></h3>
<p>The example below shows the usage of this method using the JSON-RPC protocol via
the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>
which is available in modern web-browsers or platforms like
<a href="https://deno.land/">Deno</a>.</p>
<pre><code class="language-ts">  let resp = await fetch(&quot;http://localhost:8080&quot;, {
    method: &quot;POST&quot;,
    body: JSON.stringify({
      jsonrpc: &quot;2.0&quot;,
      id: 1,
      method: &quot;data/put&quot;,
      params: {
        &quot;@type&quot;: &quot;Source&quot;,
        &quot;@id&quot;: &quot;91bbc461-4ce1-4f83-b95d-de0909575174&quot;,
        &quot;name&quot;: &quot;Inter-process communication with openLCA&quot;,
        // ...
      }
    })
  });
  let v = await resp.json();
  console.log(v);
  // {
  //   jsonrpc: &quot;2.0&quot;,
  //   id: 1,
  //   result: {
  //     &quot;@type&quot;: &quot;Source&quot;,
  //     &quot;@id&quot;: &quot;91bbc461-4ce1-4f83-b95d-de0909575174&quot;,
  //     name: &quot;Inter-process communication with openLCA&quot;
  //   }
  // }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-a-product-system"><a class="header" href="#create-a-product-system">Create a product system</a></h1>
<p>This method creates a product system for a given process. It recursively links
the processes of that system according to the given linking configuration.</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Rest API</td><td><code>GET /data/{type}/all</code></td></tr>
<tr><td>JSON-RPC</td><td><code>data/get/all</code></td></tr>
<tr><td>Python IPC</td><td><code>Client.get_all</code></td></tr>
<tr><td>Parameter</td><td><a href="https://greendelta.github.io/olca-schema/classes/Ref.html"><code>Ref[Process]</code></a></td></tr>
<tr><td>Parameter</td><td><a href="https://greendelta.github.io/olca-schema/classes/LinkingConfig.html"><code>LinkingConfig</code></a></td></tr>
<tr><td>Return type:</td><td><a href="https://greendelta.github.io/olca-schema/classes/Ref.html"><code>Ref[ProductSystem]</code></a></td></tr>
</tbody></table>
</div>
<h2 id="examples-10"><a class="header" href="#examples-10">Examples</a></h2>
<h3 id="python-ipc-9"><a class="header" href="#python-ipc-9">Python IPC</a></h3>
<pre><code class="language-py">import olca_ipc as ipc
import olca_schema as o

client = ipc.Client()
process_ref = client.find(o.Process, &quot;aluminium foil production&quot;)
config = o.LinkingConfig(
    prefer_unit_processes=True,
    provider_linking=o.ProviderLinking.PREFER_DEFAULTS,
)
system_ref = client.create_product_system(process_ref, config)
print(f&quot;created product system {system_ref.name}, id={system_ref.id}&quot;)
# created product system aluminium foil production, id=fbc33e47-ee...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="delete-a-data-set"><a class="header" href="#delete-a-data-set">Delete a data set</a></h1>
<p>Deletes the specified data set from the database. This method is not available
when the server runs in read-only mode.</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Rest API</td><td><code>DELETE /data/{type}/{id}</code></td></tr>
<tr><td>JSON-RPC</td><td><code>data/delete</code></td></tr>
<tr><td>Python/IPC</td><td><code>Client.delete</code></td></tr>
<tr><td>Return type:</td><td><a href="https://greendelta.github.io/olca-schema/classes/Ref.html"><code>Ref</code></a></td></tr>
</tbody></table>
</div>
<h2 id="examples-11"><a class="header" href="#examples-11">Examples</a></h2>
<h3 id="python-ipc-10"><a class="header" href="#python-ipc-10">Python IPC</a></h3>
<pre><code class="language-py">import olca_ipc as ipc
import olca_schema as o

client = ipc.Client()
ref = client.delete(
    o.Ref(ref_type=o.RefType.Source, id=&quot;16cba9b2-2987-4735-9f3e-96fedf8449dd&quot;)
)
print(ref)
# Ref(
#     id=&quot;16cba9b2-2987-4735-9f3e-96fedf8449dd&quot;,
#     name=&quot;Inter-process communication with openLCA&quot;,
# ...
</code></pre>
<h3 id="json-rpc-via-fetch-api-9"><a class="header" href="#json-rpc-via-fetch-api-9">JSON-RPC via Fetch API</a></h3>
<p>The example below shows the usage of this method using the JSON-RPC protocol via
the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>
which is available in modern web-browsers or platforms like
<a href="https://deno.land/">Deno</a>.</p>
<pre><code class="language-ts">  let resp = await fetch(&quot;http://localhost:8080&quot;, {
    method: &quot;POST&quot;,
    body: JSON.stringify({
      jsonrpc: &quot;2.0&quot;,
      id: 1,
      method: &quot;data/delete&quot;,
      params: {
        &quot;@type&quot;: &quot;Source&quot;,
        &quot;@id&quot;: &quot;91bbc461-4ce1-4f83-b95d-de0909575174&quot;,
      }
    })
  });
  let v = await resp.json();
  console.log(v);
  // {
  //   jsonrpc: &quot;2.0&quot;,
  //   result: {
  //     &quot;@type&quot;: &quot;Source&quot;,
  //     &quot;@id&quot;: &quot;91bbc461-4ce1-4f83-b95d-de0909575174&quot;,
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calculation-and-results"><a class="header" href="#calculation-and-results">Calculation and results</a></h1>
<p>When starting a calculation, it is first scheduled in a calculation queue. This
is because multiple calculations could be started at the same time and
calculations may need to wait for other calculations first to be finished. Thus,
a calculation directly returns a
<a href="http://greendelta.github.io/olca-schema/classes/ResultState.html">ResultState</a>
object with a unique identifier. With this identifier, the state of the
calculation can be retrieved from the server. It is then also the ID of the
corresponding result when the calculation is finished. When a result is not
needed anymore, the <code>dispose</code> method should be called so that the allocated
resources of the result can be released.</p>
<p>The idea of the result interface is not to provide some ready-to-use charts and
tables but to provide all possible building blocks with which such higher level
result views can be created (charts, tables, upstream trees, Sankey diagrams).
Thus, the result interface has many methods that often look quite similar but
they have their purpose for efficiently creating higher level result views.</p>
<h2 id="result-elements"><a class="header" href="#result-elements">Result elements</a></h2>
<p>Depending on the calculation setup and the calculated model, results can be
retrieved for different elements, these are:</p>
<ul>
<li>Technosphere flows, <code>tech-flows</code>: the product and waste flows of the product
system with their corresponding providers.</li>
<li>Intervention flows, <code>envi-flows</code>: typically elementary flows but also
unconnected product or waste inputs or outputs of the processes in the system.
These flows cross the boundary to the environment of the system and form the
inventory result of the system. In case of a regionalized calculation, an
intervention flow is a pair of flow and location.</li>
<li>Impact categories, <code>impact-categories</code>: the impact categories of the impact
assessment method selected in the calculation setup.</li>
<li>costs: life cycle costs</li>
</ul>
<p>Technosphere flows are always present. All other result elements are only
available if the calculated model provides these elements and/or if the
corresponding options are set in the calculation setup.</p>
<h2 id="mathematical-relations"><a class="header" href="#mathematical-relations">Mathematical relations</a></h2>
<p>Where possible, a short formula for calculating a respective result is provided
in the following documentation of the respective functions. These formulas are based on standard matrix algebra for <a href="https://link.springer.com/book/10.1007/978-94-015-9900-9">LCA
computations</a>.
However, this does not mean that a respective result is calculated by exactly
using this formula.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calculate-results"><a class="header" href="#calculate-results">Calculate results</a></h1>
<p>This method schedules a new calculation for a given setup. It directly returns
a state object that contains the result ID (field <code>@id</code>). With this ID the
the result state can be queried.</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>REST</td><td><code>POST result/calculate</code></td></tr>
<tr><td>IPC</td><td><code>result/calculate</code></td></tr>
<tr><td>Python IPC</td><td><code>Client.calculate</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/ResultState.html"><code>ResultState</code></a></td></tr>
<tr><td>Parameter type</td><td><a href="http://greendelta.github.io/olca-schema/classes/CalculationSetup.html">CalculationSetup</a></td></tr>
</tbody></table>
</div>
<h2 id="examples-12"><a class="header" href="#examples-12">Examples</a></h2>
<h3 id="python-ipc-11"><a class="header" href="#python-ipc-11">Python IPC</a></h3>
<pre><code class="language-py">import olca_ipc as ipc
import olca_schema as o

# create a calculation setup
setup = o.CalculationSetup(
    target=o.Ref(
        ref_type=o.RefType.ProductSystem,
        id=&quot;0db1eda6-a34e-4c82-b06b-19f27c92495a&quot;,
    ),
    impact_method=o.Ref(id=&quot;b4571628-4b7b-3e4f-81b1-9a8cca6cb3f8&quot;),
    nw_set=o.Ref(id=&quot;867fe119-0b5c-38a0-a3e6-1d845ffaedd5&quot;),
)

# run a calculation
client = ipc.Client()
result: ipc.Result = client.calculate(setup)
</code></pre>
<h3 id="json-rpc-via-fetch-api-10"><a class="header" href="#json-rpc-via-fetch-api-10">JSON-RPC via Fetch API</a></h3>
<p>The example below shows the usage of this method using the JSON-RPC protocol via
the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>
which is available in modern web-browsers or platforms like
<a href="https://deno.land/">Deno</a>.</p>
<pre><code class="language-ts">  let resp = await fetch(&quot;http://localhost:8080&quot;, {
    method: &quot;POST&quot;,
    body: JSON.stringify({
      jsonrpc: &quot;2.0&quot;,
      id: 1,
      method: &quot;result/calculate&quot;,
      params: {
        target: {
          &quot;@type&quot;: &quot;ProductSystem&quot;,
          &quot;@id&quot;: &quot;0db1eda6-a34e-4c82-b06b-19f27c92495a&quot;
        },
        impactMethod: {
          &quot;@id&quot;: &quot;b4571628-4b7b-3e4f-81b1-9a8cca6cb3f8&quot;,
        },
        nwSet: {
          &quot;@id&quot;: &quot;867fe119-0b5c-38a0-a3e6-1d845ffaedd5&quot;,
        },
        withCosts: true,
        amount: 1.0
      }
    })
  });
  let v = await resp.json();
  console.log(v);
  // {
  //   jsonrpc: &quot;2.0&quot;,
  //   result: {
  //     &quot;@id&quot;: &quot;e316a369-bf5b-4c25-a61f-3492cfca9535&quot;,
  //     isReady: false,
  //     isScheduled: true,
  //     time: 1671187585187
  //   },
  //   id: 1
  // }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get-state"><a class="header" href="#get-state">Get state</a></h1>
<p>This method returns the result state of a calculation. When a calculation is started, it is
scheduled in a calculation queue first. The calculation directly returns a result state with
a unique ID (field <code>@id</code>) of the result. Only when the state of a result is <code>ready</code>, calculation
results can be retrieved.</p>
<div class="table-wrapper"><table><thead><tr><th>API</th><th>Method</th></tr></thead><tbody>
<tr><td>REST</td><td><code>GET result/{result-id}/state</code></td></tr>
<tr><td>IPC</td><td><code>result/state</code></td></tr>
<tr><td>Python IPC</td><td><code>Result.get_state</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/ResultState.html"><code>ResultState</code></a></td></tr>
</tbody></table>
</div>
<h2 id="examples-13"><a class="header" href="#examples-13">Examples</a></h2>
<h3 id="python-ipc-12"><a class="header" href="#python-ipc-12">Python IPC</a></h3>
<pre><code class="language-py">state = result.get_state()
if state.error:
    print(f&quot;calculation failed: {state.error}&quot;)
    exit(-1)

# actively waiting for a result
import time

while not result.get_state().is_ready:
    time.sleep(1)
    print(&quot;waiting ...&quot;)

# or better do this:
state = result.wait_until_ready()
print(f&quot;result id: {state.id}&quot;)
</code></pre>
<h3 id="json-rpc-via-fetch-api-11"><a class="header" href="#json-rpc-via-fetch-api-11">JSON-RPC via Fetch API</a></h3>
<p>The example below shows the usage of this method using the JSON-RPC protocol via
the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>
which is available in modern web-browsers or platforms like
<a href="https://deno.land/">Deno</a>.</p>
<pre><code class="language-ts">  let resp = await fetch(&quot;http://localhost:8080&quot;, {
    method: &quot;POST&quot;,
    body: JSON.stringify({
      jsonrpc: &quot;2.0&quot;,
      id: 1,
      method: &quot;result/state&quot;,
      params: {
        &quot;@id&quot;: &quot;e316a369-bf5b-4c25-a61f-3492cfca9535&quot;,
      }
    })
  });
  let v = await resp.json();
  console.log(v);
  // {
  //   jsonrpc: &quot;2.0&quot;,
  //   result: {
  //     &quot;@id&quot;: &quot;e316a369-bf5b-4c25-a61f-3492cfca9535&quot;,
  //     isReady: true,
  //     isScheduled: false,
  //     time: 1671187586993
  //   },
  //   id: 1
  // }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dispose-result"><a class="header" href="#dispose-result">Dispose result</a></h1>
<p>This method should be always called when a result is not needed anymore.
It disposes the result and releases allocated resources of that result.</p>
<div class="table-wrapper"><table><thead><tr><th>API</th><th>Method</th></tr></thead><tbody>
<tr><td>REST</td><td><code>POST result/{result-id}/dispose</code></td></tr>
<tr><td>IPC</td><td><code>result/dispose</code></td></tr>
<tr><td>Python IPC</td><td><code>Result.dispose</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/ResultState.html"><code>ResultState</code></a></td></tr>
</tbody></table>
</div>
<h2 id="examples-14"><a class="header" href="#examples-14">Examples</a></h2>
<h3 id="python-ipc-13"><a class="header" href="#python-ipc-13">Python IPC</a></h3>
<pre><code class="language-py"># it is important to dispose a result when it is not needed anymore
result.dispose()
</code></pre>
<h3 id="json-rpc-via-fetch-api-12"><a class="header" href="#json-rpc-via-fetch-api-12">JSON-RPC via Fetch API</a></h3>
<p>The example below shows the usage of this method using the JSON-RPC protocol via
the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>
which is available in modern web-browsers or platforms like
<a href="https://deno.land/">Deno</a>.</p>
<pre><code class="language-ts">  let resp = await fetch(&quot;http://localhost:8080&quot;, {
    method: &quot;POST&quot;,
    body: JSON.stringify({
      jsonrpc: &quot;2.0&quot;,
      id: 1,
      method: &quot;result/dispose&quot;,
      params: {
        &quot;@id&quot;: &quot;e316a369-bf5b-4c25-a61f-3492cfca9535&quot;,
      }
    })
  });
  let v = await resp.json();
  console.log(v);
  // {
  //    jsonrpc: &quot;2.0&quot;,
  //    result: {
  //      &quot;@id&quot;: &quot;e316a369-bf5b-4c25-a61f-3492cfca9535&quot;
  //    },
  //    id: 1
  //  }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="monte-carlo-simulations"><a class="header" href="#monte-carlo-simulations">Monte Carlo Simulations</a></h1>
<p>Running a Monte Carlo Simulation is similar to a normal calculation. You first
call the <code>simulate</code> method with a calculation setup. This schedules a first
simulation run. When the calculation is ready, the result can be queried like
any other result. For each subsequent iteration you call the <code>next</code> method on
that result which schedules a new iteration, that again returns a result that
can be queried, and so on. Old iteration results are disposed automatically when
a new iteration is started but you should dispose the last result when it is not
needed anymore.</p>
<p>The API method for the first iteration is:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>REST</td><td><code>POST result/simulate</code></td></tr>
<tr><td>IPC</td><td><code>result/simulate</code></td></tr>
<tr><td>Python IPC</td><td><code>Client.simulate</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/ResultState.html"><code>ResultState</code></a></td></tr>
<tr><td>Parameter type</td><td><a href="http://greendelta.github.io/olca-schema/classes/CalculationSetup.html">CalculationSetup</a></td></tr>
</tbody></table>
</div>
<p>For each subsequent calculation, the API method is:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>REST</td><td><code>POST result/{result-id}/simulate/next</code></td></tr>
<tr><td>IPC</td><td><code>result/simulate/next</code></td></tr>
<tr><td>Python IPC</td><td><code>Result.simulate_next</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/ResultState.html"><code>ResultState</code></a></td></tr>
<tr><td>Parameter type</td><td>result id</td></tr>
</tbody></table>
</div>
<h2 id="examples-15"><a class="header" href="#examples-15">Examples</a></h2>
<h3 id="python-ipc-14"><a class="header" href="#python-ipc-14">Python IPC</a></h3>
<pre><code class="language-py">import random as rand
import statistics as stats

import olca_ipc as ipc
import olca_schema as o

client = ipc.Client()

# schedule a first iteration
print(&quot;run iteration 1&quot;)
result = client.simulate(
    o.CalculationSetup(
        target=o.Ref(
            ref_type=o.RefType.ProductSystem,
            id=&quot;7d1cbce0-b5b3-47ba-95b5-014ab3c7f569&quot;,
        ),
        impact_method=o.Ref(id=&quot;99b9d86b-ec6f-4610-ba9f-68ebfe5691dd&quot;),
    )
)
result.wait_until_ready()

# get the result for some indicator from the first iteration
indicator = rand.choice(result.get_impact_categories())
val = lambda: result.get_total_impact_value_of(indicator).amount
xs: list[float] = [val()]

# collect the values from 99 more iterations
for i in range(0, 99):
    print(f&quot;run iteration {i+2}&quot;)
    result.simulate_next()
    result.wait_until_ready()
    xs.append(val())

result.dispose()

# plot the results in a simple histogram
bucket_count = 15
quantiles = stats.quantiles(xs, n=bucket_count + 1, method=&quot;inclusive&quot;)
buckets = [0] * bucket_count
for x in xs:
    bucket = 0
    for i in range(1, bucket_count):
        if x &lt;= quantiles[i]:
            bucket += 1
    buckets[bucket] += 1
for i in buckets:
    print(f&quot;|{'#' * i}&quot;)

# ...
# run iteration 98
# run iteration 99
# run iteration 100
#
# |#######
# |######
# |######
# |######
# |######
# |#######
# |######
# |######
# |######
# |######
# |#######
# |######
# |######
# |######
# |#############
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="technosphere-flows"><a class="header" href="#technosphere-flows">Technosphere flows</a></h1>
<p>This method returns the \(n\) technosphere flows of a result. These are the
flows by which the processes of the calculated system are linked. Each
technosphere flow is a pair of a product or waste flow and a provider where the
provider is typically a process but can also be a product system (a sub-system)
or even another result. The technosphere matrix \(A\) is symmetrically indexed
by these technosphere flows:</p>
<p>$$
A \in \mathbb{R}^{n \times n}
$$</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>REST</td><td><code>result/{result-id}/tech-flows</code></td></tr>
<tr><td>IPC</td><td><code>result/tech-flows</code></td></tr>
<tr><td>Python IPC</td><td><code>Result.get_tech_flows</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/TechFlow.html"><code>List[TechFlow]</code></a></td></tr>
</tbody></table>
</div>
<h2 id="examples-16"><a class="header" href="#examples-16">Examples</a></h2>
<h3 id="python-ipc-15"><a class="header" href="#python-ipc-15">Python IPC</a></h3>
<pre><code class="language-py">tech_flows = result.get_tech_flows()
print(
    pd.DataFrame(
        [
            (tf.provider.name, tf.flow.name, tf.flow.ref_unit)
            for tf in tech_flows
        ],
        columns=[&quot;Provider&quot;, &quot;Flow&quot;, &quot;Unit&quot;],
    ).head()
)
#                               Provider                      Flow  Unit
# 0  Fresh wheat, corn, rice, and oth...  Fresh wheat, corn, ric...  USD
# 1       Synthetic dyes and pigments...       Synthetic dyes an...  USD
# 2              Cardboard containers...              Cardboard ...  USD
# 3  Synthetic rubber and artificial ...  Synthetic rubber and a...  USD
# 4                  Packaged poultry...                  Packag...  USD

</code></pre>
<h3 id="json-rpc-via-fetch-api-13"><a class="header" href="#json-rpc-via-fetch-api-13">JSON-RPC via Fetch API</a></h3>
<p>The example below shows the usage of this method using the JSON-RPC protocol via
the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>
which is available in modern web-browsers or platforms like
<a href="https://deno.land/">Deno</a>.</p>
<pre><code class="language-ts">  let resp = await fetch(&quot;http://localhost:8080&quot;, {
    method: &quot;POST&quot;,
    body: JSON.stringify({
      jsonrpc: &quot;2.0&quot;,
      id: 1,
      method: &quot;result/tech-flows&quot;,
      params: {
        &quot;@id&quot;: &quot;77ccaffa-9d79-4f38-8da5-4413469b8a7b&quot;,
      }
    })
  });
  let v = await resp.json();
  console.log(v);
  // {
  //   jsonrpc: &quot;2.0&quot;,
  //   id: 1,
  //   result: [
  //     {
  //        provider: {
  //          &quot;@type&quot;: &quot;Process&quot;,
  //          &quot;@id&quot;: &quot;7c619276-7b15-472a-b261-0110d461755a&quot;,
  //          name: &quot;market for natural gas, high pressure&quot;,
  //          processType: &quot;LCI_RESULT&quot;,
  //          flowType: &quot;PRODUCT_FLOW&quot;
  //        },
  //        flow: {
  //          &quot;@type&quot;: &quot;Flow&quot;,
  //          &quot;@id&quot;: &quot;a9007f10-7e39-4d50-8f4a-d6d03ce3d673&quot;,
  //          name: &quot;natural gas, high pressure&quot;,
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-final-demand"><a class="header" href="#the-final-demand">The final demand</a></h1>
<p>In openLCA, a product system is calculated for a single demand value for a
technosphere flow: a product output or waste input of the system. It is the
quantitative reference of the system. In the general case, a system can have
multiple demand values organized in a final demand vector \(f\) which is
indexed in the same way as the technology matrix (Note that an multi-demand
system can be transformed into a single demand system by simply adding an
additional process column to the the technology matrix). In the result
calculation, the technosphere matrix \(A\) is scaled by a scaling vector
\(s\) to fulfill the final demand.</p>
<p>$$
f = \sum_j{A[:, j] * s_j} = A * s
$$</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>REST</td><td><code>GET result/{result-id}/demand</code></td></tr>
<tr><td>IPC</td><td><code>result/demand</code></td></tr>
<tr><td>Python IPC</td><td><code>Result.get_demand</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/TechFlowValue.html"><code>TechFlowValue</code></a></td></tr>
</tbody></table>
</div>
<h3 id="json-rpc-via-fetch-api-14"><a class="header" href="#json-rpc-via-fetch-api-14">JSON-RPC via Fetch API</a></h3>
<p>The example below shows the usage of this method using the JSON-RPC protocol via
the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>
which is available in modern web-browsers or platforms like
<a href="https://deno.land/">Deno</a>.</p>
<pre><code class="language-ts">  let resp = await fetch(&quot;http://localhost:8080&quot;, {
    method: &quot;POST&quot;,
    body: JSON.stringify({
      jsonrpc: &quot;2.0&quot;,
      id: 1,
      method: &quot;result/demand&quot;,
      params: {
        &quot;@id&quot;: &quot;841c7110-4106-49d3-8447-38acc0805ca5&quot;,
      }
    })
  });
  let v = await resp.json();
  console.log(v);
  // {
  //   jsonrpc: &quot;2.0&quot;,
  //   id: 1,
  //   result: {
  //     amount: 1,
  //     techFlow: {
  //       provider: {
  //         &quot;@type&quot;: &quot;Process&quot;,
  //         &quot;@id&quot;: &quot;4446fcf6-7b87-4eb6-9529-775f3fe0c016&quot;,
  // ...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="total-requirements"><a class="header" href="#total-requirements">Total requirements</a></h1>
<p>This method returns the total requirements of technosphere flows that are needed
to fulfill the demand of the calculated product system. Mathematically, this is
the diagonal of the technosphere matrix \(A\) scaled by the scaling \(s\):</p>
<p>$$
t = diag(s) * diag(A)
$$</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>REST</td><td><code>GET result/{result-id}/total-requirements</code></td></tr>
<tr><td>IPC</td><td><code>result/total-requirements</code></td></tr>
<tr><td>Python IPC</td><td><code>Result.get_total_requirements</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/TechFlowValue.html"><code>List[TechFlowValue]</code></a></td></tr>
</tbody></table>
</div>
<p>It is also possible to get just the total requirements value of a single
technosphere flow \(j\):</p>
<p>$$
t_j = s_j * A[j, j]
$$</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>REST</td><td><code>GET result/{result-id}/total-requirements-of/{tech-flow}</code></td></tr>
<tr><td>IPC</td><td><code>result/total-requirements-of</code></td></tr>
<tr><td>Python IPC</td><td><code>Result.get_total_requirements_of</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/TechFlowValue.html"><code>TechFlowValue</code></a></td></tr>
<tr><td>Parameter type</td><td><a href="http://greendelta.github.io/olca-schema/classes/TechFlow.html"><code>TechFlow</code></a></td></tr>
</tbody></table>
</div>
<h2 id="examples-17"><a class="header" href="#examples-17">Examples</a></h2>
<h3 id="json-rpc-via-fetch-api-15"><a class="header" href="#json-rpc-via-fetch-api-15">JSON-RPC via Fetch API</a></h3>
<p>The example below shows the usage of this method using the JSON-RPC protocol via
the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>
which is available in modern web-browsers or platforms like
<a href="https://deno.land/">Deno</a>.</p>
<pre><code class="language-ts">  let resp = await fetch(&quot;http://localhost:8080&quot;, {
    method: &quot;POST&quot;,
    body: JSON.stringify({
      jsonrpc: &quot;2.0&quot;,
      id: 1,
      method: &quot;result/total-requirements&quot;,
      params: {
        &quot;@id&quot;: &quot;fa78990c-3f88-455a-9f8f-bd9e536bac28&quot;,
      }
    })
  });
  let v = await resp.json();
  console.log(v);
  // {
  //   jsonrpc: &quot;2.0&quot;,
  //   result: [
  //     { techFlow: { provider: [Object], flow: [Object] }, amount: 1 },
  //     { techFlow: { provider: [Object], flow: [Object] }, amount: 1 },
  //     { techFlow: {
  //         provider: [Object],
  //         flow: [Object] },
  //          amount: 15.151515151515152 }, ..
})();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="direct-requirements"><a class="header" href="#direct-requirements">Direct requirements</a></h1>
<p>The direct requirements of a process \(j\) are the scaled inputs and outputs
of the linked product and waste flows of that process related to the final
demand of the product system. Mathematically, it is the scaled column \(j\) of
the technology matrix \(A\):</p>
<p>$$
s_j * A[:,j]
$$</p>
<p>The returned values are negative for inputs and positive for outputs of the
respective flows. Also, the returned values contain the total requirements of
the technosphere flow \(j\) to which the other requirements are related. </p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>REST</td><td><code>GET result/{result-id}/direct-requirements-of/{tech-flow}</code></td></tr>
<tr><td>IPC</td><td><code>result/direct-requirements-of</code></td></tr>
<tr><td>Python IPC</td><td><code>Result.get_direct_requirements_of</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/TechFlowValue.html"><code>List[TechFlowValue]</code></a></td></tr>
<tr><td>Parameter type</td><td><a href="http://greendelta.github.io/olca-schema/classes/TechFlow.html"><code>TechFlow</code></a></td></tr>
</tbody></table>
</div>
<h2 id="examples-18"><a class="header" href="#examples-18">Examples</a></h2>
<h3 id="json-rpc-via-fetch-api-16"><a class="header" href="#json-rpc-via-fetch-api-16">JSON-RPC via Fetch API</a></h3>
<p>The example below shows the usage of this method using the JSON-RPC protocol via
the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>
which is available in modern web-browsers or platforms like
<a href="https://deno.land/">Deno</a>.</p>
<pre><code class="language-ts">  let resp = await fetch(&quot;http://localhost:8080&quot;, {
    method: &quot;POST&quot;,
    body: JSON.stringify({
      jsonrpc: &quot;2.0&quot;,
      id: 1,
      method: &quot;result/direct-requirements-of&quot;,
      params: {
        &quot;@id&quot;: &quot;77ccaffa-9d79-4f38-8da5-4413469b8a7b&quot;,
        techFlow: {
          provider: {
            &quot;@type&quot;: &quot;Process&quot;,
            &quot;@id&quot;: &quot;ff6b1c80-03b2-4433-adaf-66c51063b078&quot;,
          },
          flow: {
            &quot;@type&quot;: &quot;Flow&quot;,
            &quot;@id&quot;: &quot;759b89bd-3aa6-42ad-b767-5bb9ef5d331d&quot;,
          }
        }
      }
    })
  });
  let v = await resp.json();
  console.log(v);
  // {
  //   jsonrpc: &quot;2.0&quot;,
  //   result: [
  //     {
  //       techFlow: { provider: [Object], flow: [Object] },
  //       amount: 0.0029162004774116275
  //     },
  //     { techFlow: ...
})();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scaling-factors"><a class="header" href="#scaling-factors">Scaling factors</a></h1>
<p>The scaling vector \(s\) contains for each process \(j\) a factor \(s_j\)
by which the process needs to be scaled to fulfill the demand of the product
system. Mathematically, it can be calculating by solving the following equation by \(s\)
where \(A\) is the technology matrix and \(f\) the final demand vector of
the system:</p>
<p>$$
A * s = f
$$</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>REST</td><td><code>GET result/{result-id}/scaling-factors</code></td></tr>
<tr><td>IPC</td><td><code>result/scaling-factors</code></td></tr>
<tr><td>Python IPC</td><td><code>Result.get_scaling_factors</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/TechFlowValue.html"><code>List[TechFlowValue]</code></a></td></tr>
</tbody></table>
</div>
<h2 id="examples-19"><a class="header" href="#examples-19">Examples</a></h2>
<h3 id="json-rpc-via-fetch-api-17"><a class="header" href="#json-rpc-via-fetch-api-17">JSON-RPC via Fetch API</a></h3>
<p>The example below shows the usage of this method using the JSON-RPC protocol via
the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>
which is available in modern web-browsers or platforms like
<a href="https://deno.land/">Deno</a>.</p>
<pre><code class="language-ts">  let resp = await fetch(&quot;http://localhost:8080&quot;, {
    method: &quot;POST&quot;,
    body: JSON.stringify({
      jsonrpc: &quot;2.0&quot;,
      id: 1,
      method: &quot;result/scaling-factors&quot;,
      params: {
        &quot;@id&quot;: &quot;fa78990c-3f88-455a-9f8f-bd9e536bac28&quot;,
      }
    })
  });
  let v = await resp.json();
  console.log(v);
  // {
  //   jsonrpc: &quot;2.0&quot;,
  //   result: [
  //     {
  //       techFlow: { provider: [Object], flow: [Object] },
  //       amount: 0.0016129032258064518
  //     },
  //     { techFlow: ...
})();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="totality-factors"><a class="header" href="#totality-factors">Totality factors</a></h1>
<p>The concept of totality factors is a bit complicated, but they are very
useful for visualizations like Sankey diagrams. In short, they scale an
intensity result to a total result. An intensity result is related to one
unit of product output (waste input) of a technosphere flow \(j\)
including the direct, upstream, and downstream contributions. Multiplying
such an intensity with the totality factor \(tf_j\) gives the total result related
to the total requirements of product (waste) \(j\). Directly multiplying
the intensity with the total requirements would double count possible loops.</p>
<p>Mathematically, the totality factor of a technosphere flow \(j\) is calculated
by multiplying the total requirements \(t_j\) of that flow by a loop factor
\(\lambda_j\): </p>
<p>$$
tf_j = \lambda_j * t_j
$$</p>
<p>Where the loop factor is calculated via:</p>
<p>$$
\lambda_j = \frac{1}{A[j, j] * A^{-1}[j, j]}
$$</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>REST</td><td><code>GET result/{result-id}/totality-factors</code></td></tr>
<tr><td>IPC</td><td><code>result/totality-factors</code></td></tr>
<tr><td>Python IPC</td><td><code>Result.get_totality_factors</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/TechFlowValue.html"><code>List[TechFlowValue]</code></a></td></tr>
</tbody></table>
</div>
<p>As the calculation of a totality factor \(tf_j\) requires to solve the complete
system for one unit of techosphere flow \(j\), it is almost always a better idea
to only query the API for totality factors that are really needed:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>REST</td><td><code>GET result/{result-id}/totality-factor-of/{tech-flow}</code></td></tr>
<tr><td>IPC</td><td><code>result/totality-factor-of</code></td></tr>
<tr><td>Python IPC</td><td><code>Result.get_totality_factor_of</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/TechFlowValue.html"><code>TechFlowValue</code></a></td></tr>
<tr><td>Parameter type</td><td><a href="http://greendelta.github.io/olca-schema/classes/TechFlow.html"><code>TechFlow</code></a></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="unscaled-requirements"><a class="header" href="#unscaled-requirements">Unscaled requirements</a></h1>
<p>The unscaled requirements of a process \(j\) are the direct requirements of
the process related to the quantitative reference of that process without
applying a scaling factor. Mathematically, it is just the column \(j\) of
the technosphere matrix \(A\):</p>
<p>$$
A[:, j]
$$</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>REST</td><td><code>GET result/{result-id}/unscaled-requirements-of/{tech-flow}</code></td></tr>
<tr><td>IPC</td><td><code>result/unscaled-requirements-of</code></td></tr>
<tr><td>Python IPC</td><td><code>Result.get_unscaled_requirements_of</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/TechFlowValue.html"><code>List[TechFlowValue]</code></a></td></tr>
<tr><td>Parameter type</td><td><a href="http://greendelta.github.io/olca-schema/classes/TechFlow.html"><code>TechFlow</code></a></td></tr>
</tbody></table>
</div>
<h2 id="examples-20"><a class="header" href="#examples-20">Examples</a></h2>
<h3 id="json-rpc-via-fetch-api-18"><a class="header" href="#json-rpc-via-fetch-api-18">JSON-RPC via Fetch API</a></h3>
<p>The example below shows the usage of this method using the JSON-RPC protocol via
the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>
which is available in modern web-browsers or platforms like
<a href="https://deno.land/">Deno</a>.</p>
<pre><code class="language-ts">  let resp = await fetch(&quot;http://localhost:8080&quot;, {
    method: &quot;POST&quot;,
    body: JSON.stringify({
      jsonrpc: &quot;2.0&quot;,
      id: 1,
      method: &quot;result/unscaled-requirements-of&quot;,
      params: {
        &quot;@id&quot;: &quot;66dcc7d0-ce47-46bf-b77a-ada4b4c95169&quot;,
        &quot;techFlow&quot;: {
          provider: {
            &quot;@type&quot;: &quot;Process&quot;,
            &quot;@id&quot;: &quot;ff6b1c80-03b2-4433-adaf-66c51063b078&quot;,
          },
          flow: {
            &quot;@type&quot;: &quot;Flow&quot;,
            &quot;@id&quot;: &quot;759b89bd-3aa6-42ad-b767-5bb9ef5d331d&quot;,
          }
        }
      }
    })
  });
  let v = await resp.json();
  console.log(v);
  // {
  //   jsonrpc: &quot;2.0&quot;,
  //   result: [
  //     { techFlow: { provider: [Object], flow: [Object] }, amount: 3.6 },
  //     { techFlow: { ...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intervention-flows"><a class="header" href="#intervention-flows">Intervention flows</a></h1>
<p>This method returns the \(m\) intervention flows of a result. These are
the flows that cross the boundary with the environment of the calculated
system (this is why the short name is <code>EnviFlow</code> in the API). In regionalized
calculations these flows can be pairs of flows and locations, the same flow
can occur in different locations (with possibly different characterisation
factors). The rows of the intervention matrix are indexed by these \(m\)
intervention flows (and the columns by the \(n\) technosphere flows):</p>
<p>$$
B \in \mathbb{R}^{m \times n}
$$</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>REST</td><td><code>result/{result-id}/envi-flows</code></td></tr>
<tr><td>IPC</td><td><code>result/envi-flows</code></td></tr>
<tr><td>Python IPC</td><td><code>Result.get_envi_flows</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/EnviFlow.html"><code>List[EnviFlow]</code></a></td></tr>
</tbody></table>
</div>
<h2 id="examples-21"><a class="header" href="#examples-21">Examples</a></h2>
<h3 id="python-ipc-16"><a class="header" href="#python-ipc-16">Python IPC</a></h3>
<pre><code class="language-py">envi_flows = result.get_envi_flows()
print(
    pd.DataFrame(
        [
            (ef.is_input, ef.flow.name, ef.flow.category, ef.flow.ref_unit)
            for ef in envi_flows
        ],
        columns=[&quot;Is input?&quot;, &quot;Flow&quot;, &quot;Category&quot;, &quot;Unit&quot;],
    ).head()
)

#    Is input?          Flow                                     Category Unit
# 0      False   1,4-dioxane             Elementary Flows/air/unspecified   kg
# 1      False      oryzalin            Elementary Flows/soil/groundwater   kg
# 2      False    Sethoxydim            Elementary Flows/soil/groundwater   kg
# 3      False  Chlorpyrifos  Elementary Flows/air/low population density   kg
# 4      False          lead             Elementary Flows/air/unspecified   kg
</code></pre>
<h3 id="json-rpc-via-fetch-api-19"><a class="header" href="#json-rpc-via-fetch-api-19">JSON-RPC via Fetch API</a></h3>
<p>The example below shows the usage of this method using the JSON-RPC protocol via
the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>
which is available in modern web-browsers or platforms like
<a href="https://deno.land/">Deno</a>.</p>
<pre><code class="language-ts">  let resp = await fetch(&quot;http://localhost:8080&quot;, {
    method: &quot;POST&quot;,
    body: JSON.stringify({
      jsonrpc: &quot;2.0&quot;,
      id: 1,
      method: &quot;result/envi-flows&quot;,
      params: {
        &quot;@id&quot;: &quot;66dcc7d0-ce47-46bf-b77a-ada4b4c95169&quot;,
      }
    })
  });
  let v = await resp.json();
  console.log(v);
  // {
  //   jsonrpc: &quot;2.0&quot;,
  //   result: [
  //     {
  //       flow: {
  //         &quot;@type&quot;: &quot;Flow&quot;,
  //         &quot;@id&quot;: &quot;60ea7a31-8f27-46af-bfe5-66417f00088b&quot;,
  //         name: &quot;Barite&quot;,
  //         category: &quot;Elementary flows/Emission to water/ocean&quot;,
  //         flowType: &quot;ELEMENTARY_FLOW&quot;,
  //         refUnit: &quot;kg&quot;
  //       },
  //       isInput: false
  //     },
  //     {
  //       flow: {
  //         &quot;@type&quot;: &quot;Flow&quot;,
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inventory-result"><a class="header" href="#inventory-result">Inventory result</a></h1>
<p>This method returns the inventory result \(g\) of the calculated product system.
This is the amount \(g_i\) of each intervention flow \(i\) that crosses the
boundary to the environment related to the final demand of product system. It can
be calculated by multiplying the intervention matrix \(B\) with the scaling vector
\(s\):</p>
<p>$$
g = B * s
$$</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>REST</td><td><code>GET result/{result-id}/total-flows</code></td></tr>
<tr><td>IPC</td><td><code>result/total-flows</code></td></tr>
<tr><td>Python IPC</td><td><code>Result.get_total_flows</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/EnviFlowValue.html"><code>List[EnviFlowValue]</code></a></td></tr>
</tbody></table>
</div>
<p>It is also possible to get the inventory result \(g_i\) of a single flow \(i\):</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>REST</td><td><code>GET result/{result-id}/total-flow-value-of/{envi-flow}</code></td></tr>
<tr><td>IPC</td><td><code>result/total-flow-value-of</code></td></tr>
<tr><td>Python IPC</td><td><code>Result.get_total_flow_value_of</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/EnviFlowValue.html"><code>EnviFlowValue</code></a></td></tr>
<tr><td>Parameter type</td><td><a href="http://greendelta.github.io/olca-schema/classes/EnviFlow.html"><code>EnviFlow</code></a></td></tr>
</tbody></table>
</div>
<h2 id="examples-22"><a class="header" href="#examples-22">Examples</a></h2>
<h3 id="json-rpc-via-fetch-api-20"><a class="header" href="#json-rpc-via-fetch-api-20">JSON-RPC via Fetch API</a></h3>
<p>The example below shows the usage of this method using the JSON-RPC protocol via
the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>
which is available in modern web-browsers or platforms like
<a href="https://deno.land/">Deno</a>.</p>
<pre><code class="language-ts">  let resp = await fetch(&quot;http://localhost:8080&quot;, {
    method: &quot;POST&quot;,
    body: JSON.stringify({
      jsonrpc: &quot;2.0&quot;,
      id: 1,
      method: &quot;result/total-flows&quot;,
      params: {
        &quot;@id&quot;: &quot;66dcc7d0-ce47-46bf-b77a-ada4b4c95169&quot;,
      }
    })
  });
  let v = await resp.json();
  console.log(v);
  // {
  //   jsonrpc: &quot;2.0&quot;,
  //   result: [
  //     { enviFlow: { flow: [Object], isInput: false }, amount: 5.316452367058923e-12 },
  //     { enviFlow: { flow: [Object], isInput: false }, amount: 0.0000020503441278781976 },
  //     { enviFlow: { flow: [Object], isInput: false }, amount: 2.2757672132330865e-10 },
  //     { enviFlow: { flow: [Object], isInput: false }, amount: 5.003477809709274e-7 },
  //     { enviFlow: { flow: [Object], isInput: true }, amount: 0.0013196599415652454 },
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="direct-contributions"><a class="header" href="#direct-contributions">Direct contributions</a></h1>
<p>This method returns the direct contribution of each process \(j\) in the
system to the inventory result of a flow \(i\). Mathematically, it is
the row \(G[i, :]\) of the scaled intervention matrix \(G\):</p>
<p>$$
G = B * diag(s)
$$</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>REST</td><td><code>GET result/{result-id}/direct-flow-values-of/{envi-flow}</code></td></tr>
<tr><td>IPC</td><td><code>result/direct-flow-values-of</code></td></tr>
<tr><td>Python IPC</td><td><code>Result.get_direct_flow_values_of</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/TechFlowValue.html"><code>List[TechFlowValue]</code></a></td></tr>
<tr><td>Parameter type</td><td><a href="http://greendelta.github.io/olca-schema/classes/EnviFlow.html"><code>EnviFlow</code></a></td></tr>
</tbody></table>
</div>
<h2 id="examples-23"><a class="header" href="#examples-23">Examples</a></h2>
<h3 id="json-rpc-via-fetch-api-21"><a class="header" href="#json-rpc-via-fetch-api-21">JSON-RPC via Fetch API</a></h3>
<p>The example below shows the usage of this method using the JSON-RPC protocol via
the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>
which is available in modern web-browsers or platforms like
<a href="https://deno.land/">Deno</a>.</p>
<pre><code class="language-ts">  let resp = await fetch(&quot;http://localhost:8080&quot;, {
    method: &quot;POST&quot;,
    body: JSON.stringify({
      jsonrpc: &quot;2.0&quot;,
      id: 1,
      method: &quot;result/direct-flow-values-of&quot;,
      params: {
        &quot;@id&quot;: &quot;66dcc7d0-ce47-46bf-b77a-ada4b4c95169&quot;,
        enviFlow: {
          flow: {
            &quot;@type&quot;: &quot;Flow&quot;,
            &quot;@id&quot;: &quot;5f7aad3d-566c-4d0d-ad59-e765f971aa0f&quot;,
            name: &quot;Methane, fossil&quot;,
          },
        }
      }
    })
  });
  let v = await resp.json();
  console.log(v);
  // {
  //   jsonrpc: &quot;2.0&quot;,
  //   result: [
  //     {
  //       techFlow: { provider: [Object], flow: [Object] },
  //       amount: 1.5185665316633185e-8
  //     },
  //     {
  //       techFlow: { provider: [Object], flow: [Object] },
  //       amount: 0.0018045126002407595
  //     }, ...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="total-values"><a class="header" href="#total-values">Total values</a></h1>
<p>This method returns for each process \(j\) in the product system the total
inventory result for a flow \(j\) at this point in the supply chain including
the direct, upstream, and downstream (related to waste treatment) contributions.
Mathematically, this is the row \(i\) of the intensity matrix \(M\) scaled
by the totality factors \(tf\):</p>
<p>$$
M[i,:] * diag(tf)
$$</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>REST</td><td><code>GET result/{result-id}/total-flow-values-of/{envi-flow}</code></td></tr>
<tr><td>IPC</td><td><code>result/total-flow-values-of</code></td></tr>
<tr><td>Python IPC</td><td><code>Result.get_total_flow_values_of</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/TechFlowValue.html"><code>List[TechFlowValue]</code></a></td></tr>
<tr><td>Parameter type</td><td><a href="http://greendelta.github.io/olca-schema/classes/EnviFlow.html"><code>EnviFlow</code></a></td></tr>
</tbody></table>
</div>
<h2 id="examples-24"><a class="header" href="#examples-24">Examples</a></h2>
<h3 id="json-rpc-via-fetch-api-22"><a class="header" href="#json-rpc-via-fetch-api-22">JSON-RPC via Fetch API</a></h3>
<p>The example below shows the usage of this method using the JSON-RPC protocol via
the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>
which is available in modern web-browsers or platforms like
<a href="https://deno.land/">Deno</a>.</p>
<pre><code class="language-ts">  let resp = await fetch(&quot;http://localhost:8080&quot;, {
    method: &quot;POST&quot;,
    body: JSON.stringify({
      jsonrpc: &quot;2.0&quot;,
      id: 1,
      method: &quot;result/total-flow-values-of&quot;,
      params: {
        &quot;@id&quot;: &quot;66dcc7d0-ce47-46bf-b77a-ada4b4c95169&quot;,
        enviFlow: {
          flow: {
            &quot;@type&quot;: &quot;Flow&quot;,
            &quot;@id&quot;: &quot;5f7aad3d-566c-4d0d-ad59-e765f971aa0f&quot;,
            name: &quot;Methane, fossil&quot;,
          },
        }
      }
    })
  });
  let v = await resp.json();
  console.log(v);
  // {
  //   jsonrpc: &quot;2.0&quot;,
  //   result: [
  //     {
  //       techFlow: { provider: [Object], flow: [Object] },
  //       amount: 0.0037571867032375776
  //     },
  //     {
  //       techFlow: { provider: [Object], flow: [Object] },
  //       amount: 0.000006654150590167164
  //     }, ...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="direct-process-results"><a class="header" href="#direct-process-results">Direct process results</a></h1>
<p>This method returns the direct intervention flows related to the production
of a product (or treatment of a waste) of a process \(j\) in order to
fulfill the demand of the product system. Mathematically, it is the column
\(j\) of the scaled intervention matrix \(G\):</p>
<p>$$
G = B * diag(s)
$$</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>REST</td><td><code>GET result/{result-id}/direct-flows-of/{tech-flow}</code></td></tr>
<tr><td>IPC</td><td><code>result/direct-flows-of</code></td></tr>
<tr><td>Python IPC</td><td><code>Result.get_direct_flows_of</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/EnviFlowValue.html"><code>List[EnviFlowValue]</code></a></td></tr>
<tr><td>Parameter type</td><td><a href="http://greendelta.github.io/olca-schema/classes/TechFlow.html"><code>TechFlow</code></a></td></tr>
</tbody></table>
</div>
<p>It is also possible to get the direct result of a single flow \(i\):</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>REST</td><td><code>GET result/{result-id}/direct-flow-of/{envi-flow}/{tech-flow}</code></td></tr>
<tr><td>IPC</td><td><code>result/direct-flow-of</code></td></tr>
<tr><td>Python IPC</td><td><code>Result.get_direct_flow_of</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/EnviFlowValue.html"><code>EnviFlowValue</code></a></td></tr>
<tr><td>Parameter type</td><td><a href="http://greendelta.github.io/olca-schema/classes/EnviFlow.html"><code>EnviFlow</code></a></td></tr>
<tr><td>Parameter type</td><td><a href="http://greendelta.github.io/olca-schema/classes/TechFlow.html"><code>TechFlow</code></a></td></tr>
</tbody></table>
</div>
<h2 id="examples-25"><a class="header" href="#examples-25">Examples</a></h2>
<h3 id="json-rpc-via-fetch-api-23"><a class="header" href="#json-rpc-via-fetch-api-23">JSON-RPC via Fetch API</a></h3>
<p>The example below shows the usage of this method using the JSON-RPC protocol via
the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>
which is available in modern web-browsers or platforms like
<a href="https://deno.land/">Deno</a>.</p>
<pre><code class="language-ts">  let resp = await fetch(&quot;http://localhost:8080&quot;, {
    method: &quot;POST&quot;,
    body: JSON.stringify({
      jsonrpc: &quot;2.0&quot;,
      id: 1,
      method: &quot;result/direct-flows-of&quot;,
      params: {
        &quot;@id&quot;: &quot;66dcc7d0-ce47-46bf-b77a-ada4b4c95169&quot;,
        techFlow: {
          provider: {
            &quot;@type&quot;: &quot;Process&quot;,
            &quot;@id&quot;: &quot;ff6b1c80-03b2-4433-adaf-66c51063b078&quot;,
          },
          flow: {
            &quot;@type&quot;: &quot;Flow&quot;,
            &quot;@id&quot;: &quot;759b89bd-3aa6-42ad-b767-5bb9ef5d331d&quot;,
          }
        }
      }
    })
  });
  let v = await resp.json();
  console.log(v);
  // {
  //   jsonrpc: &quot;2.0&quot;,
  //   result: [
  //     { enviFlow: { flow: [Object], isInput: false },
  //       amount: 2.4884640352310415e-19 },
  //     { enviFlow: { flow: [Object], isInput: false },
  //        amount: 1.0147225898077544e-12 }, ...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="total-process-results"><a class="header" href="#total-process-results">Total process results</a></h1>
<p>This method returns the total results related to the total requirements $t_j$ of a technosphere flow
\(j\)) in the calculated product system. This includes the direct, upstream, and downstream
contributions related to $t_j$. Mathematically, it is the column \(j\) of the intensity matrix
\(M\) scaled by the totality factor \(tf_j\):</p>
<p>$$
M[:,j] * tf_j
$$</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>REST</td><td><code>GET result/{result-id}/total-flows-of/{tech-flow}</code></td></tr>
<tr><td>IPC</td><td><code>result/total-flows-of</code></td></tr>
<tr><td>Python IPC</td><td><code>Result.get_total_flows_of</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/EnviFlowValue.html"><code>List[EnviFlowValue]</code></a></td></tr>
<tr><td>Parameter type</td><td><a href="http://greendelta.github.io/olca-schema/classes/TechFlow.html"><code>TechFlow</code></a></td></tr>
</tbody></table>
</div>
<p>It is also possible to get the total result value for a single flow:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>REST</td><td><code>GET result/{result-id}/total-flow-of/{envi-flow}/{tech-flow}</code></td></tr>
<tr><td>IPC</td><td><code>result/total-flow-of</code></td></tr>
<tr><td>Python IPC</td><td><code>Result.get_total_flow_of</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/EnviFlowValue.html"><code>EnviFlowValue</code></a></td></tr>
<tr><td>Parameter type</td><td><a href="http://greendelta.github.io/olca-schema/classes/EnviFlow.html"><code>EnviFlow</code></a></td></tr>
<tr><td>Parameter type</td><td><a href="http://greendelta.github.io/olca-schema/classes/TechFlow.html"><code>TechFlow</code></a></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="intensities"><a class="header" href="#intensities">Intensities</a></h1>
<p>This method returns the total interventions related to one unit of product output or waste
input of a technosphere flow \(j\) in the supply chain. This includes direct, upstream,
and downstream contributions related to one unit of this flow. Mathematically, it is the
column \(M[:, j]\) of the intensity matrix \(M\):</p>
<p>$$
M = B * A^{-1}
$$</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>REST</td><td><code>GET result/{result-id}/total-flows-of-one/{tech-flow}</code></td></tr>
<tr><td>IPC</td><td><code>result/total-flows-of-one</code></td></tr>
<tr><td>Python IPC</td><td><code>Result.get_total_flows_of_one</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/EnviFlowValue.html"><code>List[EnviFlowValue]</code></a></td></tr>
<tr><td>Parameter type</td><td><a href="http://greendelta.github.io/olca-schema/classes/TechFlow.html"><code>TechFlow</code></a></td></tr>
</tbody></table>
</div>
<p>It is also possible to get the intensity result of a single flow:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>REST</td><td><code>GET result/{result-id}/total-flow-of-one/{envi-flow}/{tech-flow}</code></td></tr>
<tr><td>IPC</td><td><code>result/total-flow-of-one</code></td></tr>
<tr><td>Python IPC</td><td><code>Result.get_total_flow_of_one</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/EnviFlowValue.html"><code>EnviFlowValue</code></a></td></tr>
<tr><td>Parameter type</td><td><a href="http://greendelta.github.io/olca-schema/classes/EnviFlow.html"><code>EnviFlow</code></a></td></tr>
<tr><td>Parameter type</td><td><a href="http://greendelta.github.io/olca-schema/classes/TechFlow.html"><code>TechFlow</code></a></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="unscaled-flows"><a class="header" href="#unscaled-flows">Unscaled flows</a></h1>
<p>This method returns the unscaled direct interventions related to the quantitative
reference of a process \(j\). Mathematically, this is just the column
\(j\) of the intervention matrix \(B\)):</p>
<p>$$
B[:, j]
$$</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>REST</td><td><code>GET result/{result-id}/unscaled-flows-of/{tech-flow}</code></td></tr>
<tr><td>IPC</td><td><code>result/unscaled-flows-of</code></td></tr>
<tr><td>Python IPC</td><td><code>Result.get_unscaled_flows_of</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/EnviFlowValue.html"><code>List[EnviFlowValue]</code></a></td></tr>
<tr><td>Parameter type</td><td><a href="http://greendelta.github.io/olca-schema/classes/TechFlow.html"><code>TechFlow</code></a></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="upstream-results"><a class="header" href="#upstream-results">Upstream results</a></h1>
<p>This method returns the upstream results for a given path in an upstream contribution tree related to an intervention flow. If the path is empty, the root of that tree is returned.</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>REST</td><td><code>POST result/{result-id}/upstream-interventions-of/{envi-flow}</code></td></tr>
<tr><td>IPC</td><td><code>result/upstream-interventions-of</code></td></tr>
<tr><td>Python IPC</td><td><code>Result.get_upstream_interventions_of</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/UpstreamNode.html"><code>List[UpstreamNode]</code></a></td></tr>
<tr><td>Parameter</td><td><a href="http://greendelta.github.io/olca-schema/classes/EnviFlow.html"><code>EnviFlow</code></a></td></tr>
<tr><td>Parameter</td><td>the upstream path encoded as string</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="upstream-trees"><a class="header" href="#upstream-trees">Upstream trees</a></h1>
<p>This method returns the result nodes of a given intervention flow for a given
path in an upstream contribution tree. The path is a sequence of
technosphere-flows that describe the path to the parent node of the returned
nodes. If the path is empty, the root of the tree is returned. Note that such
an upstream tree can be infinitely deep when the calculated system has cycles.</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Rest API</td><td><code>POST result/{result-id}/upstream-interventions-of/{envi-flow}</code></td></tr>
<tr><td>JSON-RPC</td><td><code>result/upstream-interventions-of</code></td></tr>
<tr><td>Snake case</td><td><code>result.get_upstream_interventions_of</code></td></tr>
<tr><td>Camel case</td><td><code>result.getUpstreamInterventionsOf</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/UpstreamNode.html"><code>List[UpstreamNode]</code></a></td></tr>
<tr><td>Parameter 1</td><td><a href="http://greendelta.github.io/olca-schema/classes/EnviFlow.html"><code>EnviFlow</code></a></td></tr>
<tr><td>Parameter 2</td><td><a href="http://greendelta.github.io/olca-schema/classes/TechFlow.html"><code>List[TechFlow]</code></a></td></tr>
</tbody></table>
</div>
<h2 id="examples-26"><a class="header" href="#examples-26">Examples</a></h2>
<h3 id="olca-ipcts"><a class="header" href="#olca-ipcts">olca-ipc.ts</a></h3>
<p>The TypeScript example below uses the
<a href="https://github.com/GreenDelta/olca-ipc.ts">olca-ipc.ts</a> client API:</p>
<pre><code class="language-ts">async function main() {

  // connect to a local server running on port 8080
  const client = o.IpcClient.on(8080);
  const setup = o.CalculationSetup.of({
    target: o.Ref.of({
      id: &quot;d3a9a9b2-ec3e-4811-8617-ae853573b50b&quot;,
      refType: o.RefType.ProductSystem,
    }),
  });
  const result = await client.calculate(setup);
  await result.untilReady();

  // select the first best inventory flow and expand a tree for it
  const flow = (await result.getEnviFlows())[0];
  console.log(`upstream tree for ${flow.flow?.name} (${flow.flow?.category})`);
  await expand(result, flow, []);

  // as always, dispose the result
  result.dispose();
}

async function expand(r: o.IpcResult, flow: o.EnviFlow, path: o.TechFlow[]) {
  const level = path.length;
  const indent = &quot;  &quot;.repeat(level);
  const unit = flow.flow?.refUnit;
  const nodes = await r.getUpstreamInterventionsOf(flow, path);
  for (const node of nodes) {
    if (node.result === 0) {
      continue;
    }
    const name = node.techFlow?.provider?.name;
    const value = node.result?.toExponential(2);
    console.log(`${indent}- ${value} ${unit} :: ${name}`);

    // we stop the expansion after 3 levels; you can set other cut-offs like
    // result contributions etc.
    if (level &lt; 3) {
      const next = path.slice();
      next.push(node.techFlow!);
      await expand(r, flow, next);
    }
  }
}

main();

/*
upstream tree for COD, Chemical Oxygen Demand (Elementary flows/Emission to water/ground water)
- 1.73e-9 t :: ...
  - 1.73e-9 t :: ...
    - 7.21e-10 t :: ...
      - 3.45e-10 t :: ...
      - 2.04e-10 t :: ...
      - ...
    - 5.77e-10 t :: ...
      - 4.40e-10 t :: ...
      - 7.53e-11 t :: ...
      - 3.21e-11 t :: ...
      - ...
*/
</code></pre>
<h3 id="olca-ipcpy"><a class="header" href="#olca-ipcpy">olca-ipc.py</a></h3>
<p>The Python example below uses the
<a href="https://github.com/GreenDelta/olca-ipc.py">olca-ipc.py</a> client API:</p>
<pre><code class="language-py">import olca_ipc as ipc
import olca_schema as o


def main():

    # calculate a result
    client = ipc.Client(8080)
    setup = o.CalculationSetup(
        target=o.Ref(
            id=&quot;d3a9a9b2-ec3e-4811-8617-ae853573b50b&quot;,
            ref_type=o.RefType.ProductSystem,
        )
    )
    result = client.calculate(setup)
    result.wait_until_ready()

    # select the first best inventory flow and expand a tree for it
    flow = result.get_envi_flows()[0]
    print(f&quot;upstream tree for {flow.flow.name} ({flow.flow.category})&quot;)
    expand(result, flow, [])

    # as always, dispose the result
    result.dispose()


def expand(r: ipc.IpcResult, flow: o.EnviFlow, path: list[o.TechFlow]):
    level = len(path)
    indent = &quot;  &quot; * level
    unit = flow.flow.ref_unit
    nodes = r.get_upstream_interventions_of(flow, path)
    for node in nodes:
        if node.result == 0 or not node.tech_flow:
            continue
        name = node.tech_flow.provider.name
        value = node.result
        print(f&quot;{indent}- {value:.2E} {unit} :: {name}&quot;)

        # we stop the expansion after 3 levels; you can set other cut-offs like
        # result contributions etc.
        if level &lt; 3:
            expand(r, flow, path + [node.tech_flow])
    pass


if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="impact-categories"><a class="header" href="#impact-categories">Impact categories</a></h1>
<p>This method returns the \(l\) impact categories of a result.
The rows of the impact matrix \(C\) are indexed by these
impact categories and the columns by the \(m\) intervention
flows of the system. \(C\) contains the respective characterisation
factors of the intervention flows.</p>
<p>$$
C \in \mathbb{R}^{l \times m}
$$</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>REST</td><td><code>result/{result-id}/impact-categories</code></td></tr>
<tr><td>IPC</td><td><code>result/impact-categories</code></td></tr>
<tr><td>Python IPC</td><td><code>Result.get_impact_categories</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/Ref.html"><code>List[Ref[ImpactCategory]]</code></a></td></tr>
</tbody></table>
</div>
<h2 id="examples-27"><a class="header" href="#examples-27">Examples</a></h2>
<h3 id="python-ipc-17"><a class="header" href="#python-ipc-17">Python IPC</a></h3>
<pre><code class="language-py">impact_categories = result.get_impact_categories()
print(
    pd.DataFrame(
        [(i.name, i.ref_unit) for i in impact_categories],
        columns=[&quot;Impact category&quot;, &quot;Unit&quot;],
    )
)

#   Impact category         Unit
# 0            OZON  kg CFC11-eq
# 1            EUTR      kg N eq
# 2            SMOG     kg O3 eq
# 3             HNC         CTUh
# 4            ETOX         CTUe
# 5              HC         CTUh
# 6            HRSP  kg PM2.5 eq
# 7             GCC    kg CO2 eq
# 8            HTOX         CTUh
# 9            ACID    kg SO2-eq

</code></pre>
<h3 id="json-rpc-via-fetch-api-24"><a class="header" href="#json-rpc-via-fetch-api-24">JSON-RPC via Fetch API</a></h3>
<p>The example below shows the usage of this method using the JSON-RPC protocol via
the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>
which is available in modern web-browsers or platforms like
<a href="https://deno.land/">Deno</a>.</p>
<pre><code class="language-ts">  let resp = await fetch(&quot;http://localhost:8080&quot;, {
    method: &quot;POST&quot;,
    body: JSON.stringify({
      jsonrpc: &quot;2.0&quot;,
      id: 1,
      method: &quot;result/impact-categories&quot;,
      params: {
        &quot;@id&quot;: &quot;4780f66c-0b77-49ca-9226-c7ce4447ea2d&quot;,
      }
    })
  });
  let v = await resp.json();
  console.log(v);
  // {
  //   jsonrpc: &quot;2.0&quot;,
  //   result: [
  //     {
  //       &quot;@type&quot;: &quot;ImpactCategory&quot;,
  //       &quot;@id&quot;: &quot;2dddb0a4-2f97-3fef-a4e6-708f0b4c2554&quot;,
  //       name: &quot;Human toxicity, cancer - inorganics&quot;,
  //       category: &quot;EF 3.0 Method (adapted)&quot;,
  //       refUnit: &quot;CTUh&quot;
  //     },
  //     {
  //       &quot;@type&quot;: &quot;ImpactCategory&quot;,
  //       &quot;@id&quot;: &quot;248a3f3f-933e-3c45-a799-fad9f956e03c&quot;,
  //       name: &quot;Photochemical ozone formation&quot;,
  //       category: &quot;EF 3.0 Method (adapted)&quot;,
  //       refUnit: &quot;kg NMVOC eq&quot;
  //     },
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="impact-assessment-result"><a class="header" href="#impact-assessment-result">Impact assessment result</a></h1>
<p>This method returns the impact assessment result of the calculated product
system. It can be calculated by multiplying the characterisation matrix \(C\)
with the inventory result \(g\):</p>
<p>$$
h = C * g
$$</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>REST</td><td><code>GET result/{result-id}/total-impacts</code></td></tr>
<tr><td>IPC</td><td><code>result/total-impacts</code></td></tr>
<tr><td>Python IPC</td><td><code>Result.get_total_impacts</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/ImpactValue.html"><code>List[ImpactValue]</code></a></td></tr>
</tbody></table>
</div>
<p>It is also possible to get the impact result \(h_k\) for a single impact category
\(k\):</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>REST</td><td><code>GET result/{result-id}/total-impact-value-of/{impact-category}</code></td></tr>
<tr><td>IPC</td><td><code>result/total-impact-value-of</code></td></tr>
<tr><td>Python IPC</td><td><code>Result.get_total_impact_value_of</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/ImpactValue.html"><code>ImpactValue</code></a></td></tr>
<tr><td>Parameter type</td><td><a href="http://greendelta.github.io/olca-schema/classes/Ref.html"><code>Ref[ImpactCategory]</code></a></td></tr>
</tbody></table>
</div>
<h2 id="examples-28"><a class="header" href="#examples-28">Examples</a></h2>
<h3 id="json-rpc-via-fetch-api-25"><a class="header" href="#json-rpc-via-fetch-api-25">JSON-RPC via Fetch API</a></h3>
<p>The example below shows the usage of this method using the JSON-RPC protocol via
the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>
which is available in modern web-browsers or platforms like
<a href="https://deno.land/">Deno</a>.</p>
<pre><code class="language-ts">  let resp = await fetch(&quot;http://localhost:8080&quot;, {
    method: &quot;POST&quot;,
    body: JSON.stringify({
      jsonrpc: &quot;2.0&quot;,
      id: 1,
      method: &quot;result/total-impacts&quot;,
      params: {
        &quot;@id&quot;: &quot;86b36d3b-1dba-4804-bd61-dc5bcaf7c86c&quot;,
      }
    })
  });
  let v = await resp.json();
  console.log(v);
  // {
  //   jsonrpc: &quot;2.0&quot;,
  //   result: [
  //     {
  //       impactCategory: {
  //         &quot;@type&quot;: &quot;ImpactCategory&quot;,
  //         &quot;@id&quot;: &quot;3bc1c67f-d3e3-3891-9fea-4512107d88ef&quot;,
  //         name: &quot;Climate change&quot;,
  //         category: &quot;EF 3.0 Method (adapted)&quot;,
  //         refUnit: &quot;kg CO2 eq&quot;
  //       },
  //       amount: 0.6387478227404646
  //     },
  // ...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="normalized-results"><a class="header" href="#normalized-results">Normalized results</a></h1>
<p>This method returns the normalized impact assessment result of the calculated
product system. Mathematically, it is the impact assessment result \(h\)
devided by the respective normalization values \(nv\):</p>
<p>$$
diag(nv)^{-1} * h
$$</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>REST</td><td><code>GET result/{result-id}/total-impacts/normalized</code></td></tr>
<tr><td>IPC</td><td><code>result/total-impacts/normalized</code></td></tr>
<tr><td>Python IPC</td><td><code>Result.get_total_impacts_normalized</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/ImpactValue.html"><code>List[ImpactValue]</code></a></td></tr>
</tbody></table>
</div>
<h2 id="examples-29"><a class="header" href="#examples-29">Examples</a></h2>
<h3 id="json-rpc-via-fetch-api-26"><a class="header" href="#json-rpc-via-fetch-api-26">JSON-RPC via Fetch API</a></h3>
<p>The example below shows the usage of this method using the JSON-RPC protocol via
the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>
which is available in modern web-browsers or platforms like
<a href="https://deno.land/">Deno</a>.</p>
<pre><code class="language-ts">  let resp = await fetch(&quot;http://localhost:8080&quot;, {
    method: &quot;POST&quot;,
    body: JSON.stringify({
      jsonrpc: &quot;2.0&quot;,
      id: 1,
      method: &quot;result/total-impacts/normalized&quot;,
      params: {
        &quot;@id&quot;: &quot;15432ac4-7752-4066-a62d-31270f6a0dbd&quot;,
      }
    })
  });
  let v = await resp.json();
  console.log(v);
  //{
  //  jsonrpc: &quot;2.0&quot;,
  //  result: [
  //    {
  //      impactCategory: {
  //        &quot;@type&quot;: &quot;ImpactCategory&quot;,
  //        &quot;@id&quot;: &quot;248a3f3f-933e-3c45-a799-fad9f956e03c&quot;,
  //        name: &quot;Photochemical ozone formation&quot;,
  //        category: &quot;EF 3.0 Method (adapted)&quot;,
  //        refUnit: &quot;kg NMVOC eq&quot;
  //      },
  //      amount: 0.0010466725460636012
  //    },
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="weighted-results"><a class="header" href="#weighted-results">Weighted results</a></h1>
<p>This method returns the weighted impact assessment result of the calculated
product system. Mathematically, it is the impact assessment result \(h\)
devided by the respective normalization values \(nv\) and multiplied with
the respective weighting factors \(w\):</p>
<p>$$
diag(w) * diag(nv)^{-1} * h
$$</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>REST</td><td><code>GET result/{result-id}/total-impacts/weighted</code></td></tr>
<tr><td>IPC</td><td><code>result/total-impacts/weighted</code></td></tr>
<tr><td>Python IPC</td><td><code>Result.get_total_impacts_weighted</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/ImpactValue.html"><code>List[ImpactValue]</code></a></td></tr>
</tbody></table>
</div>
<h2 id="examples-30"><a class="header" href="#examples-30">Examples</a></h2>
<h3 id="json-rpc-via-fetch-api-27"><a class="header" href="#json-rpc-via-fetch-api-27">JSON-RPC via Fetch API</a></h3>
<p>The example below shows the usage of this method using the JSON-RPC protocol via
the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>
which is available in modern web-browsers or platforms like
<a href="https://deno.land/">Deno</a>.</p>
<pre><code class="language-ts">  let resp = await fetch(&quot;http://localhost:8080&quot;, {
    method: &quot;POST&quot;,
    body: JSON.stringify({
      jsonrpc: &quot;2.0&quot;,
      id: 1,
      method: &quot;result/total-impacts/weighted&quot;,
      params: {
        &quot;@id&quot;: &quot;546a1d13-3cae-4c9b-82d0-a18204b0c6eb&quot;,
      }
    })
  });
  let v = await resp.json();
  console.log(v);
  //{
  //  jsonrpc: &quot;2.0&quot;,
  //  result: [
  //    {
  //      {
  //        impactCategory: {
  //          &quot;@type&quot;: &quot;ImpactCategory&quot;,
  //          &quot;@id&quot;: &quot;3bc1c67f-d3e3-3891-9fea-4512107d88ef&quot;,
  //          name: &quot;Climate change&quot;,
  //          category: &quot;EF 3.0 Method (adapted)&quot;,
  //          refUnit: &quot;kg CO2 eq&quot;
  //        },
  //        amount: 2.038186234380937
  //      },
  //    },
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="direct-contributions-1"><a class="header" href="#direct-contributions-1">Direct contributions</a></h1>
<p>This method returns the direct contribution of each process \(j\) in
the system to the impact assessment result of an impact category \(k\).
Mathematically, this is the row \(H[k, :]\) of the direct impact matrix
which can be calculated in the following way:</p>
<p>$$
H = C * B * diag(s)
$$</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>REST</td><td><code>GET result/{result-id}/direct-impact-values-of/{impact-category}</code></td></tr>
<tr><td>IPC</td><td><code>result/direct-impact-values-of</code></td></tr>
<tr><td>Python IPC</td><td><code>Result.get_direct_impact_values_of</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/TechFlowValue.html"><code>List[TechFlowValue]</code></a></td></tr>
<tr><td>Parameter type</td><td><a href="http://greendelta.github.io/olca-schema/classes/Ref.html"><code>Ref[ImpactCategory]</code></a></td></tr>
</tbody></table>
</div>
<h2 id="examples-31"><a class="header" href="#examples-31">Examples</a></h2>
<h3 id="json-rpc-via-fetch-api-28"><a class="header" href="#json-rpc-via-fetch-api-28">JSON-RPC via Fetch API</a></h3>
<p>The example below shows the usage of this method using the JSON-RPC protocol via
the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>
which is available in modern web-browsers or platforms like
<a href="https://deno.land/">Deno</a>.</p>
<pre><code class="language-ts">  let resp = await fetch(&quot;http://localhost:8080&quot;, {
    method: &quot;POST&quot;,
    body: JSON.stringify({
      jsonrpc: &quot;2.0&quot;,
      id: 1,
      method: &quot;result/direct-impact-values-of&quot;,
      params: {
        &quot;@id&quot;: &quot;86b36d3b-1dba-4804-bd61-dc5bcaf7c86c&quot;,
        impactCategory: {
          &quot;@id&quot;: &quot;dbdd01d5-2be4-3ba4-8127-de89f065fda1&quot;,
        },
      }
    })
  });
  let v = await resp.json();
  console.log(v);
  //  {
  //     jsonrpc: &quot;2.0&quot;,
  //     result: [
  //       {
  //         techFlow: { provider: [Object], flow: [Object] },
  //         amount: 0.00008582892489209728
  //       },
  //       { techFlow: { provider: [Object], flow: [Object] },
  //         amount: 2.023594297933216 },
  //    ...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="direct-process-result"><a class="header" href="#direct-process-result">Direct process result</a></h1>
<p>This method returns the direct impacts of a process \(j\) in the
calculated product system. Mathematically, it is the column \(H[:, j]\)
of the direct impact matrix:</p>
<p>$$
H = C * B * diag(s)
$$</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>REST</td><td><code>GET result/{result-id}/direct-impacts-of/{tech-flow}</code></td></tr>
<tr><td>IPC</td><td><code>result/direct-impacts-of</code></td></tr>
<tr><td>Python IPC</td><td><code>Result.get_direct_impacts_of</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/ImpactValue.html"><code>List[ImpactValue]</code></a></td></tr>
<tr><td>Parameter type</td><td><a href="http://greendelta.github.io/olca-schema/classes/TechFlow.html"><code>TechFlow</code></a></td></tr>
</tbody></table>
</div>
<p>It is also possible to get the direct process result \(H[k, j]\) for a single
impact category \(k\):</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>REST</td><td><code>GET result/{result-id}/direct-impact-of/{impact-category}/{tech-flow}</code></td></tr>
<tr><td>IPC</td><td><code>result/direct-impact-of</code></td></tr>
<tr><td>Python IPC</td><td><code>Result.get_direct_impact_of</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/ImpactValue.html"><code>ImpactValue</code></a></td></tr>
<tr><td>Parameter type</td><td><a href="http://greendelta.github.io/olca-schema/classes/Ref.html"><code>Ref[ImpactCategory]</code></a></td></tr>
<tr><td>Parameter type</td><td><a href="http://greendelta.github.io/olca-schema/classes/TechFlow.html"><code>TechFlow</code></a></td></tr>
</tbody></table>
</div>
<h2 id="examples-32"><a class="header" href="#examples-32">Examples</a></h2>
<h3 id="json-rpc-via-fetch-api-29"><a class="header" href="#json-rpc-via-fetch-api-29">JSON-RPC via Fetch API</a></h3>
<p>The example below shows the usage of this method using the JSON-RPC protocol via
the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>
which is available in modern web-browsers or platforms like
<a href="https://deno.land/">Deno</a>.</p>
<pre><code class="language-ts">  let resp = await fetch(&quot;http://localhost:8080&quot;, {
    method: &quot;POST&quot;,
    body: JSON.stringify({
      jsonrpc: &quot;2.0&quot;,
      id: 1,
      method: &quot;result/direct-impacts-of&quot;,
      params: {
        &quot;@id&quot;: &quot;86b36d3b-1dba-4804-bd61-dc5bcaf7c86c&quot;,
        techFlow: {
          provider: { &quot;@id&quot;: &quot;37eb4bf5-9fbc-4caf-a24a-0e0b71b997dd&quot; },
          flow: { &quot;@id&quot;: &quot;817c3650-4fed-4ef2-b9b6-404a198834e6&quot; }
        }
      }
    })
  });
  let v = await resp.json();
  console.log(v);
  // {
  //   jsonrpc: &quot;2.0&quot;,
  //   result: [
  //     {
  //       impactCategory: {
  //         &quot;@type&quot;: &quot;ImpactCategory&quot;,
  //         &quot;@id&quot;: &quot;3bc1c67f-d3e3-3891-9fea-4512107d88ef&quot;,
  //         name: &quot;Climate change&quot;,
  //         category: &quot;EF 3.0 Method (adapted)&quot;,
  //         refUnit: &quot;kg CO2 eq&quot;
  //       },
  //       amount: 0.0008854099635082675
  //     },
  //  ...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="total-process-result"><a class="header" href="#total-process-result">Total process result</a></h1>
<p>This method returns the total impact result related to the total requirements \(t_j\) of
a technosphere flow \(j\) in the calculated product system. This includes the direct,
upstream, and downstream contributions related to $t_j$. Mathematically, it is the column
\(j\) of the impact intensity matrix \(N\) scaled by the totality factor \(tf_j\):</p>
<p>$$
M[:,j] * tf_j
$$</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>REST</td><td><code>GET result/{result-id}/total-impacts-of/{tech-flow}</code></td></tr>
<tr><td>IPC</td><td><code>result/total-impacts-of</code></td></tr>
<tr><td>Python IPC</td><td><code>Result.get_total_impacts_of</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/ImpactValue.html"><code>List[ImpactValue]</code></a></td></tr>
<tr><td>Parameter type</td><td><a href="http://greendelta.github.io/olca-schema/classes/TechFlow.html"><code>TechFlow</code></a></td></tr>
</tbody></table>
</div>
<p>It is also possible to get the total impact result for a single impact category:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>REST</td><td><code>GET result/{result-id}/total-impact-of/{impact-category}/{tech-flow}</code></td></tr>
<tr><td>IPC</td><td><code>result/total-impact-of</code></td></tr>
<tr><td>Python IPC</td><td><code>Result.get_total_impact_of</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/ImpactValue.html"><code>ImpactValue</code></a></td></tr>
<tr><td>Parameter type</td><td><a href="http://greendelta.github.io/olca-schema/classes/Ref.html"><code>Ref[ImpactCategory]</code></a></td></tr>
<tr><td>Parameter type</td><td><a href="http://greendelta.github.io/olca-schema/classes/TechFlow.html"><code>TechFlow</code></a></td></tr>
</tbody></table>
</div>
<h2 id="examples-33"><a class="header" href="#examples-33">Examples</a></h2>
<h3 id="json-rpc-via-fetch-api-30"><a class="header" href="#json-rpc-via-fetch-api-30">JSON-RPC via Fetch API</a></h3>
<p>The example below shows the usage of this method using the JSON-RPC protocol via
the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>
which is available in modern web-browsers or platforms like
<a href="https://deno.land/">Deno</a>.</p>
<pre><code class="language-ts">  let resp = await fetch(&quot;http://localhost:8080&quot;, {
    method: &quot;POST&quot;,
    body: JSON.stringify({
      jsonrpc: &quot;2.0&quot;,
      id: 1,
      method: &quot;result/total-impacts-of&quot;,
      params: {
        &quot;@id&quot;: &quot;86b36d3b-1dba-4804-bd61-dc5bcaf7c86c&quot;,
        techFlow: {
          provider: { &quot;@id&quot;: &quot;37eb4bf5-9fbc-4caf-a24a-0e0b71b997dd&quot; },
          flow: { &quot;@id&quot;: &quot;817c3650-4fed-4ef2-b9b6-404a198834e6&quot; }
        }
      }
    })
  });
  let v = await resp.json();
  console.log(v);
  // {
  //   jsonrpc: &quot;2.0&quot;,
  //   result: [
  //     {
  //       impactCategory: {
  //         &quot;@type&quot;: &quot;ImpactCategory&quot;,
  //         &quot;@id&quot;: &quot;3bc1c67f-d3e3-3891-9fea-4512107d88ef&quot;,
  //         name: &quot;Climate change&quot;,
  //         category: &quot;EF 3.0 Method (adapted)&quot;,
  //         refUnit: &quot;kg CO2 eq&quot;
  //       },
  //       amount: 0.020981112466506135
  //     },
  //  ...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intensities-1"><a class="header" href="#intensities-1">Intensities</a></h1>
<p>This method returns the total impacts related to one unit of product output or waste
input of a technosphere flow \(j\) in the supply chain. This includes direct, upstream,
and downstream contributions related to one unit of this flow. Mathematically, it is the
column \(N[:, j]\) of the impact intensity matrix \(N\):</p>
<p>$$
N = C * B * A^{-1} = C * M
$$</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>REST</td><td><code>GET result/{result-id}/total-impacts-of-one/{tech-flow}</code></td></tr>
<tr><td>IPC</td><td><code>result/total-impacts-of-one</code></td></tr>
<tr><td>Python IPC</td><td><code>Result.get_total_impacts_of_one</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/ImpactValue.html"><code>List[ImpactValue]</code></a></td></tr>
<tr><td>Parameter type</td><td><a href="http://greendelta.github.io/olca-schema/classes/TechFlow.html"><code>TechFlow</code></a></td></tr>
</tbody></table>
</div>
<p>It is also possible to get the intensity \(N[k, j]\) of a single impact category \(k\):</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>REST</td><td><code>GET result/{result-id}/total-impact-of-one/{impact-category}/{tech-flow}</code></td></tr>
<tr><td>IPC</td><td><code>result/total-impact-of-one</code></td></tr>
<tr><td>Python IPC</td><td><code>Result.get_total_impact_of_one</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/ImpactValue.html"><code>ImpactValue</code></a></td></tr>
<tr><td>Parameter type</td><td><a href="http://greendelta.github.io/olca-schema/classes/Ref.html"><code>Ref[ImpactCategory]</code></a></td></tr>
<tr><td>Parameter type</td><td><a href="http://greendelta.github.io/olca-schema/classes/TechFlow.html"><code>TechFlow</code></a></td></tr>
</tbody></table>
</div>
<h2 id="examples-34"><a class="header" href="#examples-34">Examples</a></h2>
<h3 id="json-rpc-via-fetch-api-31"><a class="header" href="#json-rpc-via-fetch-api-31">JSON-RPC via Fetch API</a></h3>
<p>The example below shows the usage of this method using the JSON-RPC protocol via
the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>
which is available in modern web-browsers or platforms like
<a href="https://deno.land/">Deno</a>.</p>
<pre><code class="language-ts">  let resp = await fetch(&quot;http://localhost:8080&quot;, {
    method: &quot;POST&quot;,
    body: JSON.stringify({
      jsonrpc: &quot;2.0&quot;,
      id: 1,
      method: &quot;result/total-impacts-of-one&quot;,
      params: {
        &quot;@id&quot;: &quot;86b36d3b-1dba-4804-bd61-dc5bcaf7c86c&quot;,
        techFlow: {
          provider: { &quot;@id&quot;: &quot;37eb4bf5-9fbc-4caf-a24a-0e0b71b997dd&quot; },
          flow: { &quot;@id&quot;: &quot;817c3650-4fed-4ef2-b9b6-404a198834e6&quot; }
        }
      }
    })
  });
  let v = await resp.json();
  console.log(v);
  // {
  //   jsonrpc: &quot;2.0&quot;,
  //   result: [
  //     {
  //       impactCategory: {
  //         &quot;@type&quot;: &quot;ImpactCategory&quot;,
  //         &quot;@id&quot;: &quot;3bc1c67f-d3e3-3891-9fea-4512107d88ef&quot;,
  //         name: &quot;Climate change&quot;,
  //         category: &quot;EF 3.0 Method (adapted)&quot;,
  //         refUnit: &quot;kg CO2 eq&quot;
  //       },
  //       amount: 1.3687522905554603
  //     },
  // ...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="upstream-results-1"><a class="header" href="#upstream-results-1">Upstream results</a></h1>
<p>This method returns the upstream results for a given path in an upstream contribution tree related to an impact category. If the path is empty, the root of that tree is returned.</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>REST</td><td><code>POST result/{result-id}/upstream-impacts-of/{impact-category}</code></td></tr>
<tr><td>IPC</td><td><code>result/upstream-impacts-of</code></td></tr>
<tr><td>Python IPC</td><td><code>Result.get_upstream_impacts_of</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/UpstreamNode.html"><code>List[UpstreamNode]</code></a></td></tr>
<tr><td>Parameter</td><td><a href="http://greendelta.github.io/olca-schema/classes/Ref.html"><code>Ref[ImpactCategory]</code></a></td></tr>
<tr><td>Parameter</td><td>the upstream path encoded as string</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="upstream-trees-1"><a class="header" href="#upstream-trees-1">Upstream trees</a></h1>
<p>This method returns the result nodes of a given impact category for a given
path in an upstream contribution tree. The path is a sequence of
technosphere-flows that describe the path to the parent node of the returned
nodes. If the path is empty, the root of the tree is returned. Note that such
an upstream tree can be infinitely deep when the calculated system has cycles.</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Rest API</td><td><code>POST result/{result-id}/upstream-impacts-of/{impact-category}</code></td></tr>
<tr><td>JSON-RPC</td><td><code>result/upstream-impacts-of</code></td></tr>
<tr><td>Snake case</td><td><code>result.get_upstream_impacts_of</code></td></tr>
<tr><td>Camel case</td><td><code>result.getUpstreamImpactsOf</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/UpstreamNode.html"><code>List[UpstreamNode]</code></a></td></tr>
<tr><td>Parameter 1</td><td><a href="http://greendelta.github.io/olca-schema/classes/Ref.html"><code>Ref[ImpactCategory]</code></a></td></tr>
<tr><td>Parameter 2</td><td><a href="http://greendelta.github.io/olca-schema/classes/TechFlow.html"><code>List[TechFlow]</code></a></td></tr>
</tbody></table>
</div>
<h2 id="examples-35"><a class="header" href="#examples-35">Examples</a></h2>
<h3 id="olca-ipcts-1"><a class="header" href="#olca-ipcts-1">olca-ipc.ts</a></h3>
<p>The TypeScript example below uses the
<a href="https://github.com/GreenDelta/olca-ipc.ts">olca-ipc.ts</a> client API:</p>
<pre><code class="language-ts">async function main() {

  // connect to a local server running on port 8080
  const client = o.IpcClient.on(8080);
  const setup = o.CalculationSetup.of({
    target: o.Ref.of({
      id: &quot;d3a9a9b2-ec3e-4811-8617-ae853573b50b&quot;,
      refType: o.RefType.ProductSystem,
    }),
    impactMethod: o.Ref.of({
      id: &quot;07370e48-dde9-4248-9a9b-7255f701da89&quot;,
    })
  });
  const result = await client.calculate(setup);
  await result.untilReady();

  // select the first best impact category and expand a tree for it
  const indicator = (await result.getImpactCategories())[0];
  console.log(`upstream tree for ${indicator.name}`);
  await expand(result, indicator, []);

  // as always, dispose the result
  result.dispose();
}

async function expand(r: o.IpcResult, indicator: o.Ref, path: o.TechFlow[]) {
  const level = path.length;
  const indent = &quot;  &quot;.repeat(level);
  const unit = indicator.refUnit;
  const nodes = await r.getUpstreamImpactsOf(indicator, path);
  for (const node of nodes) {
    if (node.result === 0) {
      continue;
    }
    const name = node.techFlow?.provider?.name;
    const value = node.result?.toExponential(2);
    console.log(`${indent}- ${value} ${unit} :: ${name}`);

    // we stop the expansion after 3 levels; you can set other cut-offs like
    // result contributions etc.
    if (level &lt; 3) {
      const next = path.slice();
      next.push(node.techFlow!);
      await expand(r, indicator, next);
    }
  }
}

main();

/*
upstream tree for Photochemical ozone formation
- 2.66e-2 kg NMVOC eq ...
  - 2.66e-2 kg NMVOC eq ...
    - 1.13e-2 kg NMVOC eq ...
      - 4.69e-3 kg NMVOC eq ...
      - 4.53e-3 kg NMVOC eq ...
      - 1.41e-3 kg NMVOC eq ...

    - 8.72e-3 kg NMVOC eq ...
      - 4.18e-3 kg NMVOC eq ...
      - 4.18e-3 kg NMVOC eq ...
      - 1.01e-4 kg NMVOC eq ...
*/
</code></pre>
<h3 id="olca-ipcpy-1"><a class="header" href="#olca-ipcpy-1">olca-ipc.py</a></h3>
<p>The Python example below uses the
<a href="https://github.com/GreenDelta/olca-ipc.py">olca-ipc.py</a> client API:</p>
<pre><code class="language-py">import olca_ipc as ipc
import olca_schema as o


def main():

    # calculate a result
    client = ipc.Client(8080)
    setup = o.CalculationSetup(
        target=o.Ref(
            id=&quot;d3a9a9b2-ec3e-4811-8617-ae853573b50b&quot;,
            ref_type=o.RefType.ProductSystem,
        ),
        impact_method=o.Ref(id=&quot;07370e48-dde9-4248-9a9b-7255f701da89&quot;),
    )
    result = client.calculate(setup)
    result.wait_until_ready()

    # select the first best impact category and expand a tree for it
    indicator = result.get_impact_categories()[0]
    print(f&quot;upstream tree for {indicator.name}&quot;)
    expand(result, indicator, [])

    # as always, dispose the result
    result.dispose()


def expand(r: ipc.IpcResult, indicator: o.Ref, path: list[o.TechFlow]):
    level = len(path)
    indent = &quot;  &quot; * level
    unit = indicator.ref_unit
    nodes = r.get_upstream_impacts_of(indicator, path)
    for node in nodes:
        if node.result == 0 or not node.tech_flow:
            continue
        name = node.tech_flow.provider.name
        value = node.result
        print(f&quot;{indent}- {value:.2E} {unit} :: {name}&quot;)

        # we stop the expansion after 3 levels; you can set other cut-offs like
        # result contributions etc.
        if level &lt; 3:
            expand(r, indicator, path + [node.tech_flow])
    pass


if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-currency-of-cost-results"><a class="header" href="#the-currency-of-cost-results">The currency of cost results</a></h1>
<p>This method returns the currency of cost results if available. This is typically
the reference currency of the underlying database.</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>REST</td><td><code>GET result/{result-id}/currency</code></td></tr>
<tr><td>IPC</td><td><code>result/currency</code></td></tr>
<tr><td>Python IPC</td><td><code>Result.get_currency</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/Ref.html"><code>Ref[Currency]</code></a></td></tr>
</tbody></table>
</div>
<h2 id="examples-36"><a class="header" href="#examples-36">Examples</a></h2>
<h3 id="python-ipc-18"><a class="header" href="#python-ipc-18">Python IPC</a></h3>
<pre><code class="language-py"></code></pre>
<h3 id="json-rpc-via-fetch-api-32"><a class="header" href="#json-rpc-via-fetch-api-32">JSON-RPC via Fetch API</a></h3>
<p>The example below shows the usage of this method using the JSON-RPC protocol via
the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>
which is available in modern web-browsers or platforms like
<a href="https://deno.land/">Deno</a>.</p>
<pre><code class="language-ts">  let resp = await fetch(&quot;http://localhost:8080&quot;, {
    method: &quot;POST&quot;,
    body: JSON.stringify({
      jsonrpc: &quot;2.0&quot;,
      id: 1,
      method: &quot;result/currency&quot;,
      params: {
        &quot;@id&quot;: &quot;66dcc7d0-ce47-46bf-b77a-ada4b4c95169&quot;,
      }
    })
  });
  let v = await resp.json();
  console.log(v);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="life-cycle-costing-result"><a class="header" href="#life-cycle-costing-result">Life cycle costing result</a></h1>
<p>This method retursn the total life cycle costing (LCC) result.</p>
<p>$$
q^T * s
$$</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Rest API</td><td><code>GET result/{result-id}/total-costs</code></td></tr>
<tr><td>JSON-RPC</td><td><code>result/total-costs</code></td></tr>
<tr><td>Snake case</td><td><code>result.get_total_costs</code></td></tr>
<tr><td>Camel case</td><td><code>result.getTotalCosts</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/CostValue.html"><code>CostValue</code></a></td></tr>
</tbody></table>
</div>
<h2 id="examples-37"><a class="header" href="#examples-37">Examples</a></h2>
<h3 id="typescript-ipc"><a class="header" href="#typescript-ipc">TypeScript IPC</a></h3>
<pre><code class="language-ts">  const totals = await result.getTotalCosts();
  const code = totals.currency?.refUnit;
  console.log(`total costs: ${totals.amount} ${code}`);
  // total costs: 60 USD
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="direct-contributions-2"><a class="header" href="#direct-contributions-2">Direct contributions</a></h1>
<p>This method returns the direct contribution of each process in the system to the
total cost result.</p>
<p>$$
q^T * diagm(s)
$$</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Rest API</td><td><code>GET result/{result-id}/cost-contributions</code></td></tr>
<tr><td>JSON-RPC</td><td><code>result/cost-contributions</code></td></tr>
<tr><td>Snake case</td><td><code>result.get_cost_contributions</code></td></tr>
<tr><td>Camel case</td><td><code>result.getCostContributions</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/TechFlowValue.html"><code>List[TechFlowValue]</code></a></td></tr>
</tbody></table>
</div>
<h2 id="examples-38"><a class="header" href="#examples-38">Examples</a></h2>
<h3 id="typescript-ipc-1"><a class="header" href="#typescript-ipc-1">TypeScript IPC</a></h3>
<pre><code class="language-ts">  const contributions = await result.getCostContributions();
  for (const c of contributions) {
    console.log(`${c.techFlow?.provider?.name}: ${c.amount} ${code}`);
  }
  // Q: 15 USD
  // P: 45 USD
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="total-cost-values"><a class="header" href="#total-cost-values">Total cost values</a></h1>
<p>$$
q^T * A^{-1}[:,j] * tf[j]
$$</p>
<p>Rest: <code>/total-costs-of/{tech-flow}</code></p>
<p>Rest: <code>/total-cost-values</code></p>
<p>$$
q^T * A^{-1} * diagm(tf)
$$</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intensities-2"><a class="header" href="#intensities-2">Intensities</a></h1>
<p>$$
q^T * A^{-1}[:,j]
$$</p>
<p>Rest: <code>/total-costs-of-one/{tech-flow}</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unscaled-costs"><a class="header" href="#unscaled-costs">Unscaled costs</a></h1>
<p>$$
q^T
$$</p>
<p>Rest: <code>/unscaled-costs</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="upstream-results-2"><a class="header" href="#upstream-results-2">Upstream results</a></h1>
<p>This method returns the upstream cost results for a given path in an upstream contribution tree. If the path is empty, the root of that tree is returned.</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>REST</td><td><code>POST result/{result-id}/upstream-costs-of</code></td></tr>
<tr><td>IPC</td><td><code>result/upstream-costs-of</code></td></tr>
<tr><td>Python IPC</td><td><code>Result.get_upstream_costs_of</code></td></tr>
<tr><td>Return type</td><td><a href="http://greendelta.github.io/olca-schema/classes/UpstreamNode.html"><code>List[UpstreamNode]</code></a></td></tr>
<tr><td>Parameter</td><td>the upstream path encoded as string</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="upstream-trees-2"><a class="header" href="#upstream-trees-2">Upstream trees</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
